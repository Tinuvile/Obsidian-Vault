
è®©æˆ‘ä¸ºæ‚¨æ•´ç†RobustMQç°æœ‰çš„æŒ‡æ ‡åŸºç¡€ç›¸å…³æ–‡ä»¶å’Œä»£ç ç»“æ„ï¼š

## ğŸ“ æŒ‡æ ‡åŸºç¡€æ–‡ä»¶ç»“æ„

### **1. æ ¸å¿ƒæŒ‡æ ‡æ¡†æ¶**

```
src/common/base/src/metrics/
â”œâ”€â”€ mod.rs                    # æŒ‡æ ‡æ¨¡å—å…¥å£ï¼Œå…¨å±€Registry
â”œâ”€â”€ counter.rs               # Counterç±»å‹æŒ‡æ ‡å®ç°
â”œâ”€â”€ gauge.rs                 # Gaugeç±»å‹æŒ‡æ ‡å®ç°  
â”œâ”€â”€ histogram.rs             # Histogramç±»å‹æŒ‡æ ‡å®ç°
â””â”€â”€ broker.rs               # BrokeræœåŠ¡çŠ¶æ€æŒ‡æ ‡
```

### **2. MQTT BrokeræŒ‡æ ‡å®ç°**

```
src/mqtt-broker/src/observability/
â”œâ”€â”€ metrics/
â”‚   â”œâ”€â”€ packets.rs          # MQTTåŒ…çº§åˆ«æŒ‡æ ‡ï¼ˆæ ¸å¿ƒï¼‰
â”‚   â”œâ”€â”€ server.rs           # æœåŠ¡å™¨ç½‘ç»œé˜Ÿåˆ—æŒ‡æ ‡
â”‚   â””â”€â”€ event_metrics.rs    # å®¢æˆ·ç«¯è¿æ¥äº‹ä»¶æŒ‡æ ‡
â””â”€â”€ system_topic/
    â””â”€â”€ packet/
        â”œâ”€â”€ packets.rs      # ç³»ç»Ÿä¸»é¢˜åŒ…ç»Ÿè®¡
        â””â”€â”€ bytes.rs        # å­—èŠ‚ç»Ÿè®¡
```

### **3. Placement CenteræŒ‡æ ‡**

```
src/placement-center/src/core/
â””â”€â”€ metrics.rs              # gRPCå’ŒRaftå­˜å‚¨æ€§èƒ½æŒ‡æ ‡
```

### **4. è¿è¡Œæ—¶æŒ‡æ ‡**

```
src/common/base/src/
â””â”€â”€ runtime.rs              # Tokioè¿è¡Œæ—¶çº¿ç¨‹ç›‘æ§
```

## ğŸ”§ æ ¸å¿ƒæŒ‡æ ‡æ¡†æ¶ä»£ç 

### **å…¨å±€Registryç®¡ç† (`src/common/base/src/metrics/mod.rs`)**

```rust
use prometheus_client::registry::Registry;
use std::sync::{LazyLock, Mutex, MutexGuard};

// å…¨å±€æŒ‡æ ‡æ³¨å†Œè¡¨
static REGISTRY: LazyLock<Mutex<Registry>> = LazyLock::new(|| Mutex::new(Registry::default()));

pub fn metrics_register_default() -> MutexGuard<'static, Registry> {
    REGISTRY.lock().unwrap()
}

// æŒ‡æ ‡å¯¼å‡ºå‡½æ•°
pub fn dump_metrics() -> String {
    let mut buffer = String::new();
    let re = metrics_register_default();
    encode(&mut buffer, &re).unwrap();
    buffer
}

// Prometheus HTTPæœåŠ¡å™¨
pub async fn register_prometheus_export(port: u32) {
    let ip = format!("0.0.0.0:{}", port);
    let route = Router::new().route("/metrics", get(route_metrics));
    let listener = tokio::net::TcpListener::bind(ip).await.unwrap();
    axum::serve(listener, route).await.unwrap();
}

pub async fn route_metrics() -> String {
    dump_metrics()
}
```

### **æŒ‡æ ‡ç±»å‹å®å®šä¹‰**

#### **CounteræŒ‡æ ‡ (`src/common/base/src/metrics/counter.rs`)**
```rust
// å®šä¹‰CounteræŒ‡æ ‡çš„å®
#[macro_export]
macro_rules! register_counter_metric {
    ($name:ident, $metric_name:expr, $help:expr,$label:ty) => {
        static $name: std::sync::LazyLock<common_base::metrics::counter::FamilyCounter<$label>> =
            std::sync::LazyLock::new(|| {
                common_base::metrics::counter::register_int_counter_family($metric_name, $help)
            });
    };
}

// å¢åŠ Counterå€¼çš„å®
#[macro_export]
macro_rules! counter_metric_inc {
    ($family:ident, $label:ident) => {{
        let family = $family.clone();
        let family_r = family.read().unwrap();
        family_r.get_or_create(&$label).inc();
    }};
}
```

#### **GaugeæŒ‡æ ‡ (`src/common/base/src/metrics/gauge.rs`)**
```rust
#[macro_export]
macro_rules! register_gauge_metric {
    ($name:ident, $metric_name:expr, $help:expr,$label:ty) => {
        static $name: std::sync::LazyLock<common_base::metrics::gauge::FamilyGauge<$label>> =
            std::sync::LazyLock::new(|| {
                common_base::metrics::gauge::register_int_gauge_family($metric_name, $help)
            });
    };
}

#[macro_export]
macro_rules! gauge_metric_inc {
    ($family:ident, $label:ident) => {{
        let family = $family.clone();
        let mut found = false;
        {
            let family_r = family.read().unwrap();
            if let Some(gauge) = family_r.get(&$label) {
                gauge.inc();
                found = true;
            };
        }
        if !found {
            let family_w = family.write().unwrap();
            family_w.get_or_create(&$label).inc();
        }
    }};
}
```

#### **HistogramæŒ‡æ ‡ (`src/common/base/src/metrics/histogram.rs`)**
```rust
#[macro_export]
macro_rules! register_histogram_metric {
    // æŒ‡æ•°æ¡¶æ¨¡å¼
    ($name:ident, $metric_name:expr, $help:expr,$label:ty, $start:expr, $factor:expr, $count:expr) => {
        static $name: std::sync::LazyLock<common_base::metrics::histogram::FamilyHistogram<$label>> =
            std::sync::LazyLock::new(|| {
                common_base::metrics::histogram::register_histogram_family_with_exponential_buckets(
                    $metric_name, $help, $start, $factor, $count
                )
            });
    };
    // çº¿æ€§æ¡¶æ¨¡å¼
    ($name:ident, $metric_name:expr, $help:expr,$label:ty, $buckets:expr) => {
        static $name: std::sync::LazyLock<common_base::metrics::histogram::FamilyHistogram<$label>> =
            std::sync::LazyLock::new(|| {
                common_base::metrics::histogram::register_histogram_family_with_buckets(
                    $metric_name, $help, $buckets
                )
            });
    };
}

#[macro_export]
macro_rules! histogram_metric_observe {
    ($family:ident, $value:ident, $label:ident) => {{
        let family = $family.clone();
        let mut found = false;
        {
            let family_r = family.read().unwrap();
            if let Some(histogram) = family_r.get(&$label) {
                histogram.observe($value);
                found = true;
            };
        }
        if !found {
            let family_w = family.write().unwrap();
            family_w.get_or_create(&$label).observe($value);
        }
    }};
}
```

## ğŸ“Š MQTT BrokeræŒ‡æ ‡å®ç°

### **åŒ…çº§åˆ«æŒ‡æ ‡ (`src/mqtt-broker/src/observability/metrics/packets.rs`)**

```rust
use prometheus_client::encoding::EncodeLabelSet;

// æ ‡ç­¾å®šä¹‰
#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct NetworkLabel {
    pub network: String,  // tcp/websocket/quic
}

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct NetworkQosLabel {
    pub network: String,
    pub qos: String,      // 0/1/2
}

// æ¥æ”¶æŒ‡æ ‡å®šä¹‰
common_base::register_gauge_metric!(
    PACKETS_RECEIVED,
    "packets_received",
    "Number of packets received",
    NetworkLabel
);

common_base::register_gauge_metric!(
    PACKETS_CONNECT_RECEIVED,
    "packets_connect_received", 
    "Number of packets connect received",
    NetworkLabel
);

common_base::register_gauge_metric!(
    PACKETS_PUBLISH_RECEIVED,
    "packets_publish_received",
    "Number of packets publish received", 
    NetworkLabel
);

// ... å…¶ä»–MQTTåŒ…ç±»å‹æŒ‡æ ‡

// å‘é€æŒ‡æ ‡å®šä¹‰
common_base::register_gauge_metric!(
    PACKETS_SENT,
    "packets_sent",
    "Number of packets sent",
    NetworkQosLabel
);

// å­—èŠ‚ç»Ÿè®¡æŒ‡æ ‡
common_base::register_gauge_metric!(
    BYTES_RECEIVED,
    "bytes_received",
    "Number of bytes received",
    NetworkLabel
);

common_base::register_gauge_metric!(
    BYTES_SENT,
    "bytes_sent", 
    "Number of bytes sent",
    NetworkQosLabel
);

// æŒ‡æ ‡è®°å½•å‡½æ•°
pub fn record_received_metrics(connection: &NetworkConnection, packet: &MqttPacket) {
    let network_label = NetworkLabel {
        network: connection.connection_type.to_string(),
    };
    
    common_base::gauge_metric_inc!(PACKETS_RECEIVED, network_label);
    
    match packet {
        MqttPacket::Connect(_, _) => {
            common_base::gauge_metric_inc!(PACKETS_CONNECT_RECEIVED, network_label);
        }
        MqttPacket::Publish(publish, _) => {
            common_base::gauge_metric_inc!(PACKETS_PUBLISH_RECEIVED, network_label);
        }
        // ... å…¶ä»–åŒ…ç±»å‹å¤„ç†
    }
}
```

### **æœåŠ¡å™¨æŒ‡æ ‡ (`src/mqtt-broker/src/observability/metrics/server.rs`)**

```rust
#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
struct LabelType {
    label: String,    // é˜Ÿåˆ—æ ‡è¯†
    r#type: String,   // request/response
}

common_base::register_gauge_metric!(
    BROKER_NETWORK_QUEUE_NUM,
    "network_queue_num",
    "broker network queue num", 
    LabelType
);

pub fn metrics_request_queue(label: &str, len: usize) {
    let label_type = LabelType {
        label: label.to_string(),
        r#type: "request".to_string(),
    };
    common_base::gauge_metric_inc_by!(BROKER_NETWORK_QUEUE_NUM, label_type, len as i64);
}

pub fn metrics_response_queue(label: &str, len: usize) {
    let label_type = LabelType {
        label: label.to_string(),
        r#type: "response".to_string(),
    };
    common_base::gauge_metric_inc_by!(BROKER_NETWORK_QUEUE_NUM, label_type, len as i64);
}
```

### **è¿æ¥äº‹ä»¶æŒ‡æ ‡ (`src/mqtt-broker/src/observability/metrics/event_metrics.rs`)**

```rust
#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
struct ClientConnectionLabels {
    client_id: String,
}

common_base::register_counter_metric!(
    CLIENT_CONNECTION_COUNTER,
    "client_connections",
    "The number of client connections, regardless of success or failure.",
    ClientConnectionLabels
);

pub fn incr_client_connection_counter(client_id: String) {
    let labels = ClientConnectionLabels { client_id };
    common_base::counter_metric_inc!(CLIENT_CONNECTION_COUNTER, labels)
}

pub fn get_client_connection_counter(client_id: String) -> u64 {
    let labels = ClientConnectionLabels { client_id };
    let mut res = 0;
    common_base::counter_metric_get!(CLIENT_CONNECTION_COUNTER, labels, res);
    res
}
```

## ğŸ—ï¸ Placement CenteræŒ‡æ ‡

### **æ€§èƒ½æŒ‡æ ‡ (`src/placement-center/src/core/metrics.rs`)**

```rust
use prometheus_client::encoding::EncodeLabelSet;
use crate::route::data::StorageDataType;

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq, Default)]
pub struct MetricsLabel {
    pub grpc_service: String,     // æœåŠ¡å
    pub grpc_path: String,        // æ–¹æ³•è·¯å¾„
    pub raft_storage_type: String, // å­˜å‚¨ç±»å‹
}

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq, Default)]
pub struct RocksDBLabels {
    pub resource_type: String,    // snapshot/log
    pub action: String,           // read/write/delete
}

// gRPCæ€§èƒ½æŒ‡æ ‡
common_base::register_counter_metric!(
    GRPC_REQUEST_NUM,
    "grpc.request.num",
    "Number of calls to the grpc request",
    MetricsLabel
);

common_base::register_histogram_metric!(
    GRPC_REQUEST_TOTAL_MS,
    "grpc.request.total.ms", 
    "TotalMs of calls to the grpc request",
    MetricsLabel,
    1.0, 2.0, 10  // æŒ‡æ•°æ¡¶ï¼š1msèµ·ï¼Œ2å€å¢é•¿ï¼Œ10ä¸ªæ¡¶
);

// Raftå­˜å‚¨æ€§èƒ½æŒ‡æ ‡
common_base::register_counter_metric!(
    RAFT_STORAGE_TOTAL_NUM,
    "raft.storage.num",
    "Total number of calls to the raft storage",
    MetricsLabel
);

common_base::register_histogram_metric!(
    RAFT_STORAGE_TOTAL_MS,
    "raft.storage.total.ms",
    "TotalMs of calls to the raft storage", 
    MetricsLabel,
    0.1, 2.0, 12  // 0.1msèµ·ï¼Œ2å€å¢é•¿ï¼Œ12ä¸ªæ¡¶
);

// RocksDBå­˜å‚¨æŒ‡æ ‡
common_base::register_counter_metric!(
    ROCKSDB_STORAGE_NUM,
    "rocksdb.storage.num",
    "Total number of calls to the rocksdb storage",
    RocksDBLabels
);

common_base::register_histogram_metric!(
    ROCKSDB_STORAGE_TOTAL_MS,
    "rocksdb.storage.total.ms",
    "TotalMs of calls to the rocksdb storage",
    RocksDBLabels,
    0.1, 2.0, 12
);

// ä¾¿ç”¨å‡½æ•°
pub fn metrics_grpc_request_incr(service: &str, path: &str) {
    let label = MetricsLabel {
        grpc_service: service.to_string(),
        grpc_path: path.to_string(),
        ..Default::default()
    };
    common_base::gauge_metric_inc!(GRPC_REQUEST_NUM, label)
}

pub fn metrics_grpc_request_ms(service: &str, path: &str, ms: f64) {
    let label = MetricsLabel {
        grpc_service: service.to_string(),
        grpc_path: path.to_string(),
        ..Default::default()
    };
    common_base::histogram_metric_observe!(GRPC_REQUEST_TOTAL_MS, ms, label)
}
```

## âš™ï¸ è¿è¡Œæ—¶æŒ‡æ ‡

### **çº¿ç¨‹ç›‘æ§ (`src/common/base/src/runtime.rs`)**

```rust
use lazy_static::lazy_static;
use prometheus::{register_int_gauge_vec, IntGaugeVec};

lazy_static! {
    // æ´»è·ƒçº¿ç¨‹æ•°
    static ref METRIC_RUNTIME_THREADS_ALIVE: IntGaugeVec = register_int_gauge_vec!(
        "runtime_threads_alive",
        "runtime threads alive",
        &[THREAD_NAME_LABEL]
    ).unwrap();
    
    // ç©ºé—²çº¿ç¨‹æ•°
    static ref METRIC_RUNTIME_THREADS_IDLE: IntGaugeVec = register_int_gauge_vec!(
        "runtime_threads_idle", 
        "runtime threads idle",
        &[THREAD_NAME_LABEL]
    ).unwrap();
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn record_thread_metrics(thread_name: &str, alive: i64, idle: i64) {
    METRIC_RUNTIME_THREADS_ALIVE
        .with_label_values(&[thread_name])
        .set(alive);
        
    METRIC_RUNTIME_THREADS_IDLE
        .with_label_values(&[thread_name])
        .set(idle);
}
```

## ğŸš€ æŒ‡æ ‡é›†æˆä½¿ç”¨

### **åœ¨æœåŠ¡å¯åŠ¨æ—¶å¯ç”¨æŒ‡æ ‡ (`src/mqtt-broker/src/lib.rs`)**

```rust
impl MqttServer {
    fn start_prometheus(&self) {
        let conf = broker_mqtt_conf();
        if conf.prometheus.enable {
            self.daemon_runtime.spawn(async move {
                register_prometheus_export(conf.prometheus.port).await;
            });
        }
    }
}
```

### **åœ¨è¯·æ±‚å¤„ç†ä¸­è®°å½•æŒ‡æ ‡**

```rust
// åœ¨MQTTåŒ…å¤„ç†æ—¶è®°å½•æŒ‡æ ‡
pub fn handle_mqtt_packet(connection: &NetworkConnection, packet: MqttPacket) {
    // è®°å½•åŒ…æ¥æ”¶æŒ‡æ ‡
    record_received_metrics(connection, &packet);
    
    // è®°å½•å­—èŠ‚æ•°æŒ‡æ ‡  
    let packet_size = calc_mqtt_packet_size(&packet);
    record_bytes_received_metrics(connection, packet_size);
    
    // å¤„ç†å…·ä½“åŒ…é€»è¾‘...
}

// åœ¨gRPCè°ƒç”¨æ—¶è®°å½•æ€§èƒ½æŒ‡æ ‡
pub async fn handle_grpc_request(service: &str, method: &str) -> Result<Response, Error> {
    let start = std::time::Instant::now();
    
    // è®°å½•è¯·æ±‚æ•°é‡
    metrics_grpc_request_incr(service, method);
    
    // æ‰§è¡Œå®é™…è¯·æ±‚
    let result = process_request().await;
    
    // è®°å½•è€—æ—¶
    let duration = start.elapsed().as_millis() as f64;
    metrics_grpc_request_ms(service, method, duration);
    
    result
}
```

## ğŸ“ˆ ç°æœ‰æŒ‡æ ‡çš„è®¿é—®æ–¹å¼

**HTTPç«¯ç‚¹**ï¼š
- MQTT Broker: `http://localhost:9999/metrics`
- Placement Center: `http://localhost:9998/metrics`

**é…ç½®æ–‡ä»¶æ§åˆ¶**ï¼š
```toml
[prometheus]
enable = true
port = 9999
```

è¿™ä¸ªå®Œæ•´çš„æŒ‡æ ‡åŸºç¡€ä¸ºäº‘åŸç”Ÿç›‘æ§æä¾›äº†åšå®çš„åŸºç¡€ï¼Œæ”¯æŒCounterã€Gaugeã€Histogramä¸‰ç§ä¸»è¦æŒ‡æ ‡ç±»å‹ï¼Œè¦†ç›–äº†MQTTåè®®ã€å­˜å‚¨æ€§èƒ½ã€ç½‘ç»œé˜Ÿåˆ—ç­‰å…³é”®æ–¹é¢ã€‚

---


æ‚¨é—®å¾—å¾ˆå¥½ï¼è®©æˆ‘åˆ†æä¸€ä¸‹å½“å‰RobustMQçš„æŒ‡æ ‡ç°çŠ¶å’Œç¼ºå¤±çš„ä¸šåŠ¡å…³é”®æŒ‡æ ‡ã€‚

## ğŸ“Š å½“å‰æŒ‡æ ‡ç°çŠ¶åˆ†æ

### **å·²æœ‰æŒ‡æ ‡ï¼ˆåå‘æŠ€æœ¯å®ç°å±‚é¢ï¼‰**

```rust
ç°æœ‰æŒ‡æ ‡åˆ†ç±»ï¼š
â”œâ”€â”€ åè®®å±‚æŒ‡æ ‡
â”‚   â”œâ”€â”€ packets_connect_received     # CONNECTåŒ…æ•°é‡
â”‚   â”œâ”€â”€ packets_publish_received     # PUBLISHåŒ…æ•°é‡  
â”‚   â”œâ”€â”€ packets_subscribe_received   # SUBSCRIBEåŒ…æ•°é‡
â”‚   â”œâ”€â”€ bytes_received/sent          # å­—èŠ‚ç»Ÿè®¡
â”‚   â””â”€â”€ packets_received_error       # é”™è¯¯åŒ…æ•°é‡
â”‚
â”œâ”€â”€ æ€§èƒ½æŒ‡æ ‡  
â”‚   â”œâ”€â”€ grpc_request_total_ms        # gRPCè°ƒç”¨è€—æ—¶
â”‚   â”œâ”€â”€ raft_storage_total_ms        # Raftå­˜å‚¨æ“ä½œè€—æ—¶
â”‚   â”œâ”€â”€ rocksdb_storage_total_ms     # RocksDBæ“ä½œè€—æ—¶
â”‚   â””â”€â”€ network_queue_num            # ç½‘ç»œé˜Ÿåˆ—é•¿åº¦
â”‚
â””â”€â”€ è¿è¡Œæ—¶æŒ‡æ ‡
    â”œâ”€â”€ runtime_threads_alive        # æ´»è·ƒçº¿ç¨‹æ•°
    â”œâ”€â”€ runtime_threads_idle         # ç©ºé—²çº¿ç¨‹æ•°  
    â””â”€â”€ broker_status               # æœåŠ¡çŠ¶æ€
```

### **âŒ ç¼ºå¤±çš„ä¸šåŠ¡å…³é”®æŒ‡æ ‡**

## ğŸ¯ éœ€è¦æ·»åŠ çš„ä¸šåŠ¡å…³é”®æŒ‡æ ‡

### **1. é›†ç¾¤å¥åº·æŒ‡æ ‡**

**é—®é¢˜**ï¼šè¿ç»´å›¢é˜Ÿæ— æ³•å¿«é€Ÿäº†è§£é›†ç¾¤æ•´ä½“å¥åº·çŠ¶æ€

```rust
// å½“å‰ç¼ºå¤±çš„é›†ç¾¤æŒ‡æ ‡
common_base::register_gauge_metric!(
    CLUSTER_LEADER_STATUS,
    "robustmq_cluster_leader_status", 
    "Is this node the cluster leader (1=leader, 0=follower)",
    K8sAwareLabel
);

common_base::register_gauge_metric!(
    CLUSTER_NODES_TOTAL,
    "robustmq_cluster_nodes_total",
    "Total number of nodes in the cluster", 
    K8sAwareLabel
);

common_base::register_gauge_metric!(
    CLUSTER_NODES_HEALTHY,
    "robustmq_cluster_nodes_healthy",
    "Number of healthy nodes in the cluster",
    K8sAwareLabel
);

common_base::register_counter_metric!(
    CLUSTER_LEADER_ELECTIONS_TOTAL,
    "robustmq_cluster_leader_elections_total",
    "Total number of leader elections",
    K8sAwareLabel
);

// ä½¿ç”¨ç¤ºä¾‹
pub fn record_cluster_metrics() {
    let cluster_info = get_cluster_info();
    let label = K8sAwareLabel::from_env();
    
    // è®°å½•æ˜¯å¦ä¸ºLeader
    if cluster_info.is_leader() {
        common_base::gauge_metric_set!(CLUSTER_LEADER_STATUS, label.clone(), 1);
    } else {
        common_base::gauge_metric_set!(CLUSTER_LEADER_STATUS, label.clone(), 0);
    }
    
    // è®°å½•é›†ç¾¤èŠ‚ç‚¹æ•°
    common_base::gauge_metric_set!(CLUSTER_NODES_TOTAL, label.clone(), cluster_info.total_nodes());
    common_base::gauge_metric_set!(CLUSTER_NODES_HEALTHY, label, cluster_info.healthy_nodes());
}
```

### **2. MQTTä¸šåŠ¡æŒ‡æ ‡**

**é—®é¢˜**ï¼šæ— æ³•äº†è§£MQTTä¸šåŠ¡çš„æ ¸å¿ƒæŒ‡æ ‡

```rust
// è¿æ¥ç®¡ç†æŒ‡æ ‡
common_base::register_gauge_metric!(
    MQTT_CONNECTIONS_ACTIVE,
    "robustmq_mqtt_connections_active",
    "Number of active MQTT connections",
    ServiceLabel  // æŒ‰æœåŠ¡åˆ†ç±»
);

common_base::register_histogram_metric!(
    MQTT_CONNECTION_DURATION_SECONDS,
    "robustmq_mqtt_connection_duration_seconds", 
    "Duration of MQTT connections",
    ServiceLabel,
    [60.0, 300.0, 900.0, 3600.0, 21600.0, 86400.0]  // 1minåˆ°1å¤©
);

// æ¶ˆæ¯å¤„ç†æŒ‡æ ‡
common_base::register_histogram_metric!(
    MQTT_MESSAGE_PROCESSING_LATENCY_SECONDS,
    "robustmq_mqtt_message_processing_latency_seconds",
    "Message processing latency from receive to deliver", 
    MessageLabel,  // æŒ‰QoSã€ä¸»é¢˜ç±»å‹åˆ†ç±»
    [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
);

common_base::register_counter_metric!(
    MQTT_MESSAGES_TOTAL,
    "robustmq_mqtt_messages_total",
    "Total number of MQTT messages processed",
    MessageLabel
);

// ä¸»é¢˜å’Œè®¢é˜…æŒ‡æ ‡
common_base::register_gauge_metric!(
    MQTT_TOPICS_ACTIVE,
    "robustmq_mqtt_topics_active", 
    "Number of active topics with subscribers",
    ServiceLabel
);

common_base::register_gauge_metric!(
    MQTT_SUBSCRIPTIONS_TOTAL,
    "robustmq_mqtt_subscriptions_total",
    "Total number of active subscriptions",
    TopicLabel  // æŒ‰ä¸»é¢˜æ¨¡å¼åˆ†ç±»
);

// æ¶ˆæ¯ç§¯å‹æŒ‡æ ‡
common_base::register_gauge_metric!(
    MQTT_MESSAGES_PENDING,
    "robustmq_mqtt_messages_pending",
    "Number of pending messages awaiting delivery",
    QosLabel
);

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct MessageLabel {
    pub qos: String,           // "0", "1", "2"
    pub topic_type: String,    // "system", "user", "retained"
    pub network: String,       // "tcp", "websocket", "quic"
}

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct TopicLabel {
    pub topic_pattern: String, // "single_level", "multi_level", "exact"
    pub shared: String,        // "true", "false"
}
```

### **3. å­˜å‚¨å’Œèµ„æºæŒ‡æ ‡**

**é—®é¢˜**ï¼šæ— æ³•ç›‘æ§å­˜å‚¨ä½¿ç”¨æƒ…å†µå’Œèµ„æºæ¶ˆè€—

```rust
// å­˜å‚¨ä½¿ç”¨æŒ‡æ ‡
common_base::register_gauge_metric!(
    STORAGE_DISK_USAGE_BYTES,
    "robustmq_storage_disk_usage_bytes",
    "Disk usage in bytes for data storage",
    StorageLabel
);

common_base::register_gauge_metric!(
    STORAGE_DISK_AVAILABLE_BYTES, 
    "robustmq_storage_disk_available_bytes",
    "Available disk space in bytes",
    StorageLabel
);

common_base::register_counter_metric!(
    STORAGE_OPERATIONS_TOTAL,
    "robustmq_storage_operations_total", 
    "Total number of storage operations",
    StorageOperationLabel
);

// å†…å­˜ä½¿ç”¨æŒ‡æ ‡
common_base::register_gauge_metric!(
    MEMORY_USAGE_BYTES,
    "robustmq_memory_usage_bytes",
    "Memory usage by component",
    ComponentLabel
);

// Raftæ—¥å¿—æŒ‡æ ‡
common_base::register_gauge_metric!(
    RAFT_LOG_ENTRIES_TOTAL,
    "robustmq_raft_log_entries_total",
    "Total number of raft log entries",
    ServiceLabel
);

common_base::register_gauge_metric!(
    RAFT_LOG_LAST_APPLIED_INDEX,
    "robustmq_raft_log_last_applied_index", 
    "Index of last applied raft log entry",
    ServiceLabel
);

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct StorageLabel {
    pub storage_type: String,  // "raft_logs", "message_data", "metadata"
    pub node_id: String,
}

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct StorageOperationLabel {
    pub operation: String,     // "read", "write", "delete", "compact"
    pub storage_type: String,
    pub result: String,        // "success", "error"
}
```

### **4. é”™è¯¯å’Œå‘Šè­¦æŒ‡æ ‡**

**é—®é¢˜**ï¼šç¼ºå°‘ç»†ç²’åº¦çš„é”™è¯¯åˆ†ç±»å’Œå‘Šè­¦ä¾æ®

```rust
// è¯¦ç»†é”™è¯¯åˆ†ç±»
common_base::register_counter_metric!(
    MQTT_ERRORS_TOTAL,
    "robustmq_mqtt_errors_total",
    "Total number of MQTT errors by type", 
    ErrorLabel
);

common_base::register_counter_metric!(
    MQTT_DISCONNECTIONS_TOTAL,
    "robustmq_mqtt_disconnections_total",
    "Total number of client disconnections by reason",
    DisconnectionLabel  
);

// å®‰å…¨ç›¸å…³æŒ‡æ ‡
common_base::register_counter_metric!(
    AUTH_ATTEMPTS_TOTAL,
    "robustmq_auth_attempts_total",
    "Total number of authentication attempts",
    AuthLabel
);

common_base::register_counter_metric!(
    ACL_VIOLATIONS_TOTAL, 
    "robustmq_acl_violations_total",
    "Total number of ACL violations",
    AclLabel
);

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct ErrorLabel {
    pub error_type: String,    // "protocol_violation", "auth_failure", "resource_limit"
    pub error_code: String,    // MQTTé”™è¯¯ç 
    pub component: String,     // "broker", "placement_center"
}

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct DisconnectionLabel {
    pub reason: String,        // "client_disconnect", "keep_alive_timeout", "server_shutdown"
    pub clean_session: String, // "true", "false"
}

#[derive(Eq, Hash, Clone, EncodeLabelSet, Debug, PartialEq)]
pub struct AuthLabel {
    pub auth_method: String,   // "plaintext", "jwt", "x509"
    pub result: String,        // "success", "failure"
    pub failure_reason: String, // "invalid_credentials", "expired_token"
}
```

## ğŸ” ä¸ºä»€ä¹ˆéœ€è¦è¿™äº›ä¸šåŠ¡æŒ‡æ ‡

### **1. è¿ç»´å†³ç­–æ”¯æŒ**

```
å½“å‰æƒ…å†µï¼šåªçŸ¥é“æŠ€æœ¯æŒ‡æ ‡
â”œâ”€â”€ "gRPCè°ƒç”¨è€—æ—¶2ms"
â”œâ”€â”€ "æ”¶åˆ°1000ä¸ªPUBLISHåŒ…"
â””â”€â”€ "RocksDBå†™å…¥æ­£å¸¸"

éœ€è¦çš„ä¸šåŠ¡è§†è§’ï¼š
â”œâ”€â”€ "å½“å‰æœ‰500ä¸ªæ´»è·ƒå®¢æˆ·ç«¯"
â”œâ”€â”€ "æ¶ˆæ¯å¹³å‡å¤„ç†å»¶è¿Ÿ50ms"  
â”œâ”€â”€ "topic/sensor/+æœ‰200ä¸ªè®¢é˜…è€…"
â””â”€â”€ "é›†ç¾¤Leaderç¨³å®šï¼Œæ— é¢‘ç¹é€‰ä¸¾"
```

### **2. æ€§èƒ½ä¼˜åŒ–æŒ‡å¯¼**

```
æŠ€æœ¯æŒ‡æ ‡ vs ä¸šåŠ¡æŒ‡æ ‡ï¼š

æŠ€æœ¯ï¼špackets_publish_received = 1000/s
ä¸šåŠ¡ï¼šmessage_processing_latency_p99 = 500ms
â†’ è¯´æ˜ï¼šååé‡é«˜ä½†å»¶è¿Ÿä¹Ÿé«˜ï¼Œéœ€è¦ä¼˜åŒ–å¤„ç†é€»è¾‘

æŠ€æœ¯ï¼šraft_storage_total_ms = 10ms  
ä¸šåŠ¡ï¼šcluster_leader_elections_totalå¢é•¿
â†’ è¯´æ˜ï¼šå­˜å‚¨æ€§èƒ½æ­£å¸¸ï¼Œä½†é›†ç¾¤ä¸ç¨³å®šï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜
```

### **3. å‘Šè­¦è§„åˆ™åˆ¶å®š**

```yaml
# åŸºäºä¸šåŠ¡æŒ‡æ ‡çš„å‘Šè­¦è§„åˆ™æ›´æœ‰æ„ä¹‰
- alert: MQTTHighConnectionLatency
  expr: histogram_quantile(0.95, robustmq_mqtt_message_processing_latency_seconds) > 0.1
  
- alert: MQTTClusterUnstable  
  expr: increase(robustmq_cluster_leader_elections_total[1h]) > 3
  
- alert: MQTTHighErrorRate
  expr: rate(robustmq_mqtt_errors_total[5m]) / rate(robustmq_mqtt_messages_total[5m]) > 0.01
```

### **4. å®¹é‡è§„åˆ’æ”¯æŒ**

```
ä¸šåŠ¡æŒ‡æ ‡å¸®åŠ©å®¹é‡è§„åˆ’ï¼š
â”œâ”€â”€ mqtt_connections_active â†’ éœ€è¦å¤šå°‘BrokerèŠ‚ç‚¹
â”œâ”€â”€ mqtt_topics_active â†’ å†…å­˜éœ€æ±‚ä¼°ç®—
â”œâ”€â”€ storage_disk_usage_bytes â†’ å­˜å‚¨æ‰©å®¹æ—¶æœº
â””â”€â”€ message_processing_latency â†’ æ€§èƒ½ç“¶é¢ˆè¯†åˆ«
```

## ğŸ“ˆ å®ç°ä¼˜å…ˆçº§å»ºè®®

### **ç¬¬ä¸€ä¼˜å…ˆçº§ï¼ˆç«‹å³éœ€è¦ï¼‰**
1. **é›†ç¾¤å¥åº·æŒ‡æ ‡** - è¿ç»´å¿…éœ€
2. **æ´»è·ƒè¿æ¥æ•°** - å®¹é‡ç›‘æ§
3. **æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ** - æ€§èƒ½ç›‘æ§
4. **é”™è¯¯åˆ†ç±»ç»Ÿè®¡** - æ•…éšœæ’æŸ¥

### **ç¬¬äºŒä¼˜å…ˆçº§ï¼ˆè¿‘æœŸæ·»åŠ ï¼‰**
1. **ä¸»é¢˜è®¢é˜…ç»Ÿè®¡** - ä¸šåŠ¡åˆ†æ
2. **å­˜å‚¨ä½¿ç”¨ç›‘æ§** - å®¹é‡è§„åˆ’
3. **è®¤è¯å®‰å…¨æŒ‡æ ‡** - å®‰å…¨å®¡è®¡

### **ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼ˆé•¿æœŸå®Œå–„ï¼‰**
1. **è¯¦ç»†çš„æ¶ˆæ¯ç§¯å‹** - æ€§èƒ½è°ƒä¼˜
2. **ç½‘ç»œè¿æ¥è´¨é‡** - ç½‘ç»œä¼˜åŒ–
3. **ç»†ç²’åº¦èµ„æºä½¿ç”¨** - ç²¾ç»†åŒ–è¿ç»´

**æ€»ç»“**ï¼šå½“å‰çš„æŒ‡æ ‡ä¸»è¦åæ˜ "ç³»ç»Ÿåœ¨åšä»€ä¹ˆ"ï¼Œè€Œç¼ºå°‘"ä¸šåŠ¡æ•ˆæœå¦‚ä½•"çš„å…³é”®æŒ‡æ ‡ã€‚æ·»åŠ è¿™äº›ä¸šåŠ¡æŒ‡æ ‡å°†å¤§å¤§æå‡è¿ç»´å›¢é˜Ÿå¯¹RobustMQé›†ç¾¤å¥åº·çŠ¶å†µå’Œä¸šåŠ¡è¡¨ç°çš„æ´å¯Ÿèƒ½åŠ›ã€‚
