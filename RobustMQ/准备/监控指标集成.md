
## ğŸ“Š ç›‘æ§æŒ‡æ ‡é›†æˆå…¨æ™¯

### **å¯è§‚æµ‹æ€§ä¸‰å¤§æ”¯æŸ±**

åœ¨äº‘åŸç”Ÿç¯å¢ƒä¸­ï¼Œè¿ç»´å›¢é˜Ÿéœ€è¦**å…¨æ–¹ä½äº†è§£ç³»ç»ŸçŠ¶æ€**ï¼š

```
ğŸ” å¯è§‚æµ‹æ€§ = æŒ‡æ ‡(Metrics) + æ—¥å¿—(Logs) + é“¾è·¯è¿½è¸ª(Traces)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ğŸ“ˆ æŒ‡æ ‡ç›‘æ§    â”‚  â”‚   ğŸ“ æ—¥å¿—åˆ†æ    â”‚  â”‚   ğŸ”— é“¾è·¯è¿½è¸ª   â”‚
â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚
â”‚ CPU/å†…å­˜ä½¿ç”¨ç‡   â”‚  â”‚ é”™è¯¯æ—¥å¿—          â”‚  â”‚ è¯·æ±‚è°ƒç”¨é“¾       â”‚
â”‚ QPS/å»¶è¿Ÿ        â”‚  â”‚ è®¿é—®æ—¥å¿—          â”‚  â”‚ æ€§èƒ½ç“¶é¢ˆ         â”‚
â”‚ é›†ç¾¤çŠ¶æ€         â”‚  â”‚ ç³»ç»Ÿäº‹ä»¶          â”‚  â”‚ ä¾èµ–å…³ç³»         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                    â†“                    â†“
    å‘Šè­¦&è‡ªåŠ¨åŒ–           æ•…éšœæ’æŸ¥&å®¡è®¡         æ€§èƒ½ä¼˜åŒ–&æ¶æ„æ”¹è¿›
```

### **RobustMQç›‘æ§éœ€æ±‚**

**ä¸šåŠ¡å±‚ç›‘æ§**ï¼š
```
MQTT BrokeræŒ‡æ ‡ï¼š
â”œâ”€â”€ è¿æ¥æ•°ç»Ÿè®¡ (å½“å‰è¿æ¥ã€å†å²å³°å€¼)
â”œâ”€â”€ æ¶ˆæ¯ååé‡ (å‘å¸ƒ/è®¢é˜… QPS)  
â”œâ”€â”€ ä¸»é¢˜è®¢é˜…ç»Ÿè®¡
â”œâ”€â”€ æ¶ˆæ¯å»¶è¿Ÿåˆ†å¸ƒ
â””â”€â”€ é”™è¯¯ç‡ç»Ÿè®¡

Placement CenteræŒ‡æ ‡ï¼š
â”œâ”€â”€ é›†ç¾¤èŠ‚ç‚¹çŠ¶æ€
â”œâ”€â”€ Leaderé€‰ä¸¾æ¬¡æ•°
â”œâ”€â”€ Raftæ—¥å¿—åŒæ­¥å»¶è¿Ÿ
â””â”€â”€ å­˜å‚¨ä½¿ç”¨æƒ…å†µ
```

**åŸºç¡€è®¾æ–½å±‚ç›‘æ§**ï¼š
```
KubernetesæŒ‡æ ‡ï¼š
â”œâ”€â”€ Podèµ„æºä½¿ç”¨ (CPU/å†…å­˜/ç£ç›˜)
â”œâ”€â”€ å®¹å™¨é‡å¯æ¬¡æ•°
â”œâ”€â”€ ç½‘ç»œæµé‡ç»Ÿè®¡
â””â”€â”€ å­˜å‚¨IOPSç»Ÿè®¡
```

## ğŸ“ˆ 1. PrometheusæŒ‡æ ‡é›†æˆ

### **RobustMQç°æœ‰æŒ‡æ ‡åŸºç¡€åˆ†æ**

ä»ä»£ç åˆ†æçœ‹ï¼ŒRobustMQå·²ç»æœ‰ç›¸å½“å®Œå–„çš„æŒ‡æ ‡åŸºç¡€ï¼š

```rust
ç°æœ‰æŒ‡æ ‡ç±»å‹ï¼š
â”œâ”€â”€ MQTTåè®®æŒ‡æ ‡ (packets.rs)
â”‚   â”œâ”€â”€ packets_received/sent (æŒ‰ç½‘ç»œç±»å‹åˆ†ç±»)
â”‚   â”œâ”€â”€ bytes_received/sent
â”‚   â””â”€â”€ å„ç§MQTTåŒ…ç±»å‹ç»Ÿè®¡
â”œâ”€â”€ æ€§èƒ½æŒ‡æ ‡ (placement-center)
â”‚   â”œâ”€â”€ GRPCè¯·æ±‚å»¶è¿Ÿå’Œæ•°é‡
â”‚   â”œâ”€â”€ Raftå­˜å‚¨æ“ä½œæ€§èƒ½
â”‚   â””â”€â”€ RocksDBå­˜å‚¨æ“ä½œ
â””â”€â”€ ç³»ç»ŸæŒ‡æ ‡
    â”œâ”€â”€ è¿è¡Œæ—¶çº¿ç¨‹çŠ¶æ€
    â”œâ”€â”€ ç½‘ç»œé˜Ÿåˆ—é•¿åº¦
    â””â”€â”€ å®¢æˆ·ç«¯è¿æ¥è®¡æ•°
```

## ğŸ“ˆ 1. PrometheusæŒ‡æ ‡å¢å¼º

### **å½“å‰æŒ‡æ ‡çš„äº‘åŸç”ŸåŒ–æ”¹é€ **

**é—®é¢˜ï¼šç°æœ‰æŒ‡æ ‡ç¼ºå°‘K8sæ ‡å‡†æ ‡ç­¾**
```rust
// ç°æœ‰æ ‡ç­¾ç»“æ„
#[derive(EncodeLabelSet)]
pub struct NetworkLabel {
    pub network: String,  // åªæœ‰ç½‘ç»œç±»å‹
}

// ç¼ºå°‘K8sç¯å¢ƒä¿¡æ¯ï¼šPodåã€å‘½åç©ºé—´ã€èŠ‚ç‚¹ç­‰
```

**è§£å†³æ–¹æ¡ˆï¼šæ·»åŠ K8sæ ‡å‡†æ ‡ç­¾**
```rust
// å¢å¼ºçš„æ ‡ç­¾ç»“æ„
#[derive(EncodeLabelSet)]
pub struct K8sAwareLabel {
    // åŸæœ‰æ ‡ç­¾
    pub network: String,
    pub qos: String,
    
    // K8sæ ‡å‡†æ ‡ç­¾
    pub pod_name: String,           // placement-center-0
    pub namespace: String,          // robustmq-production
    pub node_name: String,          // k8s-worker-1
    pub service_name: String,       // placement-center
    pub cluster_name: String,       // robustmq-cluster-prod
    pub version: String,            // 0.3.0
}

impl K8sAwareLabel {
    pub fn from_env() -> Self {
        Self {
            pod_name: std::env::var("HOSTNAME")
                .unwrap_or_else(|_| "unknown-pod".to_string()),
            namespace: std::env::var("POD_NAMESPACE")
                .unwrap_or_else(|_| "default".to_string()),
            node_name: std::env::var("NODE_NAME")
                .unwrap_or_else(|_| "unknown-node".to_string()),
            service_name: std::env::var("SERVICE_NAME")
                .unwrap_or_else(|_| "robustmq".to_string()),
            cluster_name: std::env::var("CLUSTER_NAME")
                .unwrap_or_else(|_| "robustmq-cluster".to_string()),
            version: std::env::var("APP_VERSION")
                .unwrap_or_else(|_| "unknown".to_string()),
            // ... å…¶ä»–å­—æ®µ
        }
    }
}
```

**åœ¨K8séƒ¨ç½²ä¸­æ³¨å…¥ç¯å¢ƒå˜é‡**ï¼š
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: placement-center
spec:
  template:
    spec:
      containers:
      - name: placement-center
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: SERVICE_NAME
          value: "placement-center"
        - name: CLUSTER_NAME
          value: "robustmq-cluster"
        - name: APP_VERSION
          value: "0.3.0"
```

### **æ·»åŠ ä¸šåŠ¡å…³é”®æŒ‡æ ‡**

```rust
// é›†ç¾¤å¥åº·æŒ‡æ ‡
common_base::register_gauge_metric!(
    CLUSTER_LEADER_STATUS,
    "robustmq_cluster_leader_status",
    "Is this node the cluster leader (1=leader, 0=follower)",
    K8sAwareLabel
);

common_base::register_gauge_metric!(
    CLUSTER_NODE_COUNT,
    "robustmq_cluster_nodes_total",
    "Total number of nodes in the cluster",
    K8sAwareLabel
);

// MQTTä¸šåŠ¡æŒ‡æ ‡
common_base::register_histogram_metric!(
    MESSAGE_LATENCY,
    "robustmq_message_latency_seconds",
    "Message processing latency distribution",
    K8sAwareLabel,
    [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
);

common_base::register_gauge_metric!(
    ACTIVE_CONNECTIONS,
    "robustmq_connections_active",
    "Number of active MQTT connections",
    K8sAwareLabel
);

// å­˜å‚¨å¥åº·æŒ‡æ ‡
common_base::register_gauge_metric!(
    STORAGE_DISK_USAGE_BYTES,
    "robustmq_storage_disk_usage_bytes",
    "Disk usage in bytes",
    K8sAwareLabel
);
```

### **ServiceMonitoré›†æˆ**

```yaml
# monitoring/servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: robustmq-metrics
  labels:
    app: robustmq
spec:
  selector:
    matchLabels:
      app: robustmq
  endpoints:
  - port: metrics          # Serviceä¸­å®šä¹‰çš„æŒ‡æ ‡ç«¯å£
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s
    relabelings:
    - sourceLabels: [__meta_kubernetes_pod_name]
      targetLabel: pod
    - sourceLabels: [__meta_kubernetes_namespace]
      targetLabel: namespace
```

## ğŸ“Š 2. Grafanaä»ªè¡¨æ¿è®¾è®¡

### **å¤šå±‚æ¬¡ä»ªè¡¨æ¿æ¶æ„**

**1. é›†ç¾¤æ¦‚è§ˆä»ªè¡¨æ¿**
```json
{
  "dashboard": {
    "title": "RobustMQ Cluster Overview",
    "panels": [
      {
        "title": "Cluster Health",
        "type": "stat",
        "query": "robustmq_cluster_nodes_total",
        "thresholds": [
          {"color": "red", "value": 0},
          {"color": "yellow", "value": 1}, 
          {"color": "green", "value": 3}
        ]
      },
      {
        "title": "Message Throughput",
        "type": "graph",
        "query": "rate(robustmq_packets_publish_received[5m])",
        "legend": "{{pod}} - {{namespace}}"
      },
      {
        "title": "Active Connections",
        "type": "graph",
        "query": "robustmq_connections_active",
        "legend": "{{service_name}}"
      }
    ]
  }
}
```

**2. MQTT Brokerè¯¦ç»†ä»ªè¡¨æ¿**
```json
{
  "dashboard": {
    "title": "RobustMQ MQTT Broker Details", 
    "panels": [
      {
        "title": "Message Latency P99",
        "type": "graph",
        "query": "histogram_quantile(0.99, robustmq_message_latency_seconds)",
        "alert": {
          "condition": "gt 1.0",
          "message": "High message latency detected"
        }
      },
      {
        "title": "Connection Rate",
        "type": "graph", 
        "query": "rate(robustmq_packets_connect_received[1m])"
      },
      {
        "title": "Error Rate",
        "type": "stat",
        "query": "rate(robustmq_packets_received_error[5m])",
        "thresholds": [
          {"color": "green", "value": 0},
          {"color": "yellow", "value": 0.01},
          {"color": "red", "value": 0.05}
        ]
      }
    ]
  }
}
```

**3. Placement Centerä»ªè¡¨æ¿**
```json
{
  "dashboard": {
    "title": "RobustMQ Placement Center",
    "panels": [
      {
        "title": "Leader Election",
        "type": "graph",
        "query": "robustmq_cluster_leader_status",
        "legend": "{{pod_name}}"
      },
      {
        "title": "Raft Log Replication Latency", 
        "type": "graph",
        "query": "robustmq_raft_storage_total_ms"
      },
      {
        "title": "Storage Disk Usage",
        "type": "gauge",
        "query": "robustmq_storage_disk_usage_bytes"
      }
    ]
  }
}
```

### **ä»ªè¡¨æ¿é…ç½®ç®¡ç†**

```yaml
# grafana/dashboards-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: robustmq-dashboards
  labels:
    grafana_dashboard: "1"    # Grafanaè‡ªåŠ¨å‘ç°æ ‡ç­¾
data:
  cluster-overview.json: |
    {{ .Files.Get "dashboards/cluster-overview.json" | indent 4 }}
  mqtt-broker.json: |
    {{ .Files.Get "dashboards/mqtt-broker.json" | indent 4 }}
  placement-center.json: |
    {{ .Files.Get "dashboards/placement-center.json" | indent 4 }}
```

## ğŸ“ 3. æ—¥å¿—èšåˆ (Fluent Bité›†æˆ)

### **æ—¥å¿—æ ‡å‡†åŒ–æ”¹é€ **

**å½“å‰é—®é¢˜ï¼šæ—¥å¿—æ ¼å¼ä¸ç»Ÿä¸€**
```rust
// ç°æœ‰æ—¥å¿—æ ¼å¼æ··ä¹±
info!("Connection established: {}", client_id);
error!("Failed to process message");
debug!("Raft log entry: {:?}", entry);
```

**è§£å†³æ–¹æ¡ˆï¼šç»“æ„åŒ–æ—¥å¿—**
```rust
use tracing::{info, error, debug, instrument};
use serde_json::json;

// ç»Ÿä¸€çš„æ—¥å¿—ç»“æ„
#[derive(serde::Serialize)]
struct LogEvent {
    level: String,
    message: String,
    component: String,
    client_id: Option<String>,
    topic: Option<String>,
    trace_id: Option<String>,
    #[serde(flatten)]
    extra: serde_json::Value,
}

// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—
pub fn log_connection_event(client_id: &str, event_type: &str, success: bool) {
    info!(
        target: "mqtt.connection",
        client_id = %client_id,
        event_type = %event_type, 
        success = %success,
        component = "mqtt-broker",
        "MQTT connection event"
    );
}

pub fn log_message_processing(topic: &str, qos: u8, latency_ms: f64) {
    info!(
        target: "mqtt.message",
        topic = %topic,
        qos = %qos,
        latency_ms = %latency_ms,
        component = "mqtt-broker",
        "Message processed successfully"
    );
}
```

### **Fluent Bité…ç½®**

```yaml
# fluent-bit-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         1
        Log_Level     info
        Daemon        off
        Parsers_File  parsers.conf
        HTTP_Server   On
        HTTP_Listen   0.0.0.0
        HTTP_Port     2020

    [INPUT]
        Name              tail
        Path              /var/log/containers/robustmq-*_*.log
        Parser            docker
        Tag               robustmq.*
        Refresh_Interval  5
        Mem_Buf_Limit     50MB

    [FILTER]
        Name                kubernetes
        Match               robustmq.*
        Kube_URL            https://kubernetes.default.svc:443
        Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token
        Merge_Log           On
        K8S-Logging.Parser  On
        K8S-Logging.Exclude Off

    [FILTER]
        Name    grep
        Match   robustmq.*
        Regex   log_level (INFO|WARN|ERROR)

    [OUTPUT]
        Name  es
        Match robustmq.*
        Host  elasticsearch.monitoring.svc.cluster.local
        Port  9200
        Index robustmq-logs
        Type  _doc

  parsers.conf: |
    [PARSER]
        Name        docker
        Format      json
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L
        Time_Keep   On

    [PARSER]
        Name        robustmq
        Format      regex
        Regex       ^(?<time>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\s+(?<level>\w+)\s+(?<component>\w+):\s+(?<message>.*)$
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%LZ
```

### **æ—¥å¿—æŸ¥è¯¢å’Œå‘Šè­¦**

```json
// ElasticsearchæŸ¥è¯¢ç¤ºä¾‹
{
  "query": {
    "bool": {
      "must": [
        {"term": {"kubernetes.labels.app": "robustmq"}},
        {"term": {"level": "ERROR"}},
        {"range": {"@timestamp": {"gte": "now-1h"}}}
      ]
    }
  },
  "aggs": {
    "errors_by_component": {
      "terms": {"field": "component.keyword"}
    }
  }
}
```

## ğŸ”— 4. é“¾è·¯è¿½è¸ª (OpenTelemetry)

### **åˆ†å¸ƒå¼è¿½è¸ªæ¶æ„**

```
å®¢æˆ·ç«¯å‘å¸ƒæ¶ˆæ¯çš„å®Œæ•´é“¾è·¯ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MQTT Client  â”‚â”€â”€â”€â–¶â”‚ MQTT Broker  â”‚â”€â”€â”€â–¶â”‚Placement Ctr â”‚
â”‚              â”‚    â”‚              â”‚    â”‚              â”‚
â”‚ publish()    â”‚    â”‚ receive()    â”‚    â”‚ store_meta() â”‚
â”‚ trace_id:123 â”‚    â”‚ trace_id:123 â”‚    â”‚ trace_id:123 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚Journal Serverâ”‚
                    â”‚              â”‚
                    â”‚ persist()    â”‚
                    â”‚ trace_id:123 â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **OpenTelemetryé›†æˆå®ç°**

```rust
// Cargo.toml
[dependencies]
opentelemetry = "0.21"
opentelemetry-jaeger = "0.20"
tracing-opentelemetry = "0.22"
tracing-subscriber = "0.3"

// trace.rs
use opentelemetry::{global, trace::TraceContextExt, Context, KeyValue};
use opentelemetry_jaeger::new_agent_pipeline;
use tracing_opentelemetry::OpenTelemetryLayer;
use tracing_subscriber::{layer::SubscriberExt, Registry};

pub fn init_tracing(service_name: &str) -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–Jaeger tracer
    let tracer = new_agent_pipeline()
        .with_service_name(service_name)
        .with_endpoint("http://jaeger-agent.monitoring.svc.cluster.local:14268/api/traces")
        .install_batch(opentelemetry::runtime::Tokio)?;
    
    // é…ç½®tracing subscriber
    let subscriber = Registry::default()
        .with(OpenTelemetryLayer::new(tracer))
        .with(tracing_subscriber::fmt::layer());
    
    tracing::subscriber::set_global_default(subscriber)?;
    Ok(())
}

// åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    init_tracing("robustmq-mqtt-broker")?;
    
    // åº”ç”¨é€»è¾‘...
    Ok(())
}
```

### **å…³é”®è·¯å¾„è¿½è¸ªå®ç°**

```rust
use tracing::{instrument, info_span, Instrument};
use opentelemetry::trace::{Span, Tracer};

// MQTTæ¶ˆæ¯å¤„ç†é“¾è·¯è¿½è¸ª
#[instrument(
    name = "mqtt.publish.handle",
    fields(
        client_id = %client_id,
        topic = %topic,
        qos = %qos,
    )
)]
pub async fn handle_publish_message(
    client_id: &str,
    topic: &str, 
    payload: &[u8],
    qos: u8,
) -> Result<(), MqttError> {
    // åˆ›å»ºspan
    let span = info_span!("mqtt.message.receive");
    
    // æ¶ˆæ¯éªŒè¯
    validate_message(topic, payload).instrument(span.clone()).await?;
    
    // å­˜å‚¨åˆ°placement-center
    let storage_span = info_span!("placement_center.store", 
        operation = "store_message_metadata"
    );
    store_message_metadata(client_id, topic)
        .instrument(storage_span)
        .await?;
    
    // æŒä¹…åŒ–åˆ°journal
    let persist_span = info_span!("journal.persist",
        operation = "write_message"
    );
    persist_message(payload)
        .instrument(persist_span)
        .await?;
    
    // åˆ†å‘ç»™è®¢é˜…è€…
    let deliver_span = info_span!("mqtt.deliver",
        operation = "fanout_message"
    );
    deliver_to_subscribers(topic, payload)
        .instrument(deliver_span)
        .await?;
    
    Ok(())
}

// è·¨æœåŠ¡è°ƒç”¨ä¼ æ’­trace context
pub async fn call_placement_center(
    request: PlacementRequest
) -> Result<PlacementResponse, GrpcError> {
    let mut client = self.grpc_client.clone();
    
    // æå–å½“å‰trace context
    let context = Context::current();
    let span_context = context.span().span_context();
    
    // åœ¨gRPC metadataä¸­ä¼ æ’­trace ID
    let mut metadata = tonic::metadata::MetadataMap::new();
    metadata.insert(
        "trace-id",
        span_context.trace_id().to_string().parse().unwrap()
    );
    metadata.insert(
        "span-id", 
        span_context.span_id().to_string().parse().unwrap()
    );
    
    let mut request = tonic::Request::new(request);
    *request.metadata_mut() = metadata;
    
    client.store_metadata(request).await
}
```

### **Jaegeréƒ¨ç½²é…ç½®**

```yaml
# jaeger.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jaeger
  template:
    spec:
      containers:
      - name: jaeger
        image: jaegertracing/all-in-one:1.50
        env:
        - name: COLLECTOR_ZIPKIN_HOST_PORT
          value: ":9411"
        - name: SPAN_STORAGE_TYPE
          value: elasticsearch
        - name: ES_SERVER_URLS
          value: http://elasticsearch.monitoring.svc.cluster.local:9200
        ports:
        - containerPort: 16686  # Jaeger UI
        - containerPort: 14268  # Jaeger collector
---
apiVersion: v1
kind: Service
metadata:
  name: jaeger
spec:
  ports:
  - port: 16686
    name: ui
  - port: 14268
    name: collector
  selector:
    app: jaeger
```

## ğŸš¨ 5. å‘Šè­¦å’Œè‡ªåŠ¨åŒ–

### **Prometheuså‘Šè­¦è§„åˆ™**

```yaml
# alerts.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: robustmq-alerts
spec:
  groups:
  - name: robustmq.cluster
    rules:
    - alert: RobustMQClusterDown
      expr: robustmq_cluster_nodes_total < 2
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "RobustMQ cluster has insufficient nodes"
        description: "Only {{ $value }} nodes available, minimum 2 required"
        
    - alert: RobustMQHighLatency
      expr: histogram_quantile(0.99, robustmq_message_latency_seconds) > 1.0
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High message processing latency"
        description: "P99 latency is {{ $value }}s"
        
    - alert: RobustMQHighErrorRate
      expr: rate(robustmq_packets_received_error[5m]) > 0.05
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "High error rate detected"
        description: "Error rate: {{ $value | humanizePercentage }}"
```

è¿™ä¸ªå…¨é¢çš„ç›‘æ§é›†æˆæ–¹æ¡ˆå°†ä¸ºRobustMQæä¾›ç”Ÿäº§çº§çš„å¯è§‚æµ‹æ€§èƒ½åŠ›ï¼Œå¸®åŠ©è¿ç»´å›¢é˜Ÿå¿«é€Ÿå‘ç°å’Œè§£å†³é—®é¢˜ã€‚
