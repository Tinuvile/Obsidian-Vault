{
	"nodes":[
		{"id":"737b349daad0a249","type":"text","text":"## 基本类型\n![[Rust数据类型]]\n\nRust是一门静态类型语言（编译器必须在编译期知道所有变量的类型）。不过大部分情况Rust编译器可以根据变量的值和上下文的使用方式来**自动推导**变量的类型，但也有一些**无法推导**的情况，这时就需要手动进行标注。","x":-20,"y":-320,"width":520,"height":360,"color":"5"},
		{"id":"725fc9af7668037f","type":"text","text":"## 数值类型\n- **整数类型**：\n    - 默认使用`i32`，`isize`和`usize`类型取决于程序运行的计算机CPU类型。\n    - 当用`debug`模式编译会检查整型溢出，`release`模式不检查。标准库中有一些处理可能的溢出的方法。\n- **浮点类型**：默认使用`f64`，浮点一定谨慎：\n     - 浮点数往往是近似\n     - 浮点数在某些特性上是反直觉的\n - **`NaN`**\n - **数字运算**：加减乘除和取模\n - **位运算**\n   ![[位运算]]\n - **序列**：如`1..5`可以生成从1到4的连续数字，`1..5=5`可以生成从1到5的连续数字，字符同理。\n - **使用`As`完成类型转换**：可以用来类型转换，常用于将原始类型转换为其他原始类型。\n - **有理数和复数**：未包含在标准库中，但有社区数值库`num`\n","x":440,"y":-1160,"width":600,"height":680,"color":"5"},
		{"id":"691eae7cc7e633b0","type":"text","text":"## 字符、布尔、单元类型\n- 字符类型：Rust中的字符不止是`ASCII`，所有`Unicode`值都可以作为Rust字符。`Unicode`是4个字节编码，字符类型也是占用4个字节。\n- 布尔：`true`和`false`，它占用内存大小为1个字节。\n- 单元类型：单元类型是`()`，它唯一的值也是`()`。`main()`函数和`println!()`的返回值就是单元类型。我们可以使用它来占位，不占用任何内存，表示我们不关注具体的值。","x":-560,"y":237,"width":629,"height":233,"color":"5"},
		{"id":"922c3bb0d079703c","type":"text","text":"## 语句和表达式\n> [!important]\n> 语句会执行一些操作但不会返回一个值，表达式会在求值后返回一个值。\n\n值得注意的是：**表达式不能包含分号**，一旦在表达式后面加上分号，它就会编程一条语句。另外，表达式如果不返回任何值，那么会隐式地返回一个`()`。\n```rust\nfn add_with_extra(x: i32, y: i32) -> i32 {\n    let x = x + 1; // 语句\n    let y = y + 5; // 语句\n    x + y // 表达式\n}\n```","x":440,"y":237,"width":600,"height":447,"color":"5"},
		{"id":"d8054fe6afb00f93","type":"text","text":"## 函数\n```rust\nfn add(i: i32, j: i32) -> i32 {\n   i + j\n }\n```\n\n - 在Rust中函数就是表达式\n - Rust不关心我们在哪里定义函数，只要有定义即可\n - Rust需要你为每个函数参数都标识出它的具体类型\n - 函数的返回值就是函数体最后一条表达式的返回值，也可以用`return`提前返回\n\nRust有一些特殊返回类型：\n- 单元类型`()`：函数没有返回值或者通过`;`结尾的语句都返回`()`\n- **永不返回的发散函数`!`**：当用`!`作函数返回类型的时候，表示该函数永不返回，这种语法往往用做会导致程序崩溃的函数\n```rust\nfn dead_end() -> ! {\n  panic!(\"你已经到了穷途末路，崩溃吧！\");\n}\n```\n","x":800,"y":-429,"width":600,"height":579,"color":"5"},
		{"id":"e6b35e9fef1bd8e2","type":"text","text":"## 变量\n- **变量绑定**：把**内存对象**绑定给一个变量，使得这个变量成为它的主人，相应的，它的前任主人就会丧失该内存对象的所有权。\n  示例：`let a = \"hello world\"`\n- **变量可变性**：默认情况下Rust变量是**不可变的**，但可以通过`mut`关键字让变量变为**可变的**。\n  示例：`let mut x = 5`\n- **使用下划线开头忽略未使用的变量**：这样可以让Rust不要警告。\n  示例：`let _x = 5`\n- **变量解构**：`let`表达式还可以进行复杂变量的解构，从一个相对复杂的变量中匹配出该变量的一部分内容。\n  示例：`let (a, mut b): (bool, bool) = (true, false)`\n- **模式解构赋值**：这种是对**已声明**变量的**再赋值**，但是有一定要求\n  示例：\n```rust\nstruct Struct {\n    e: i32\n}\n\nfn main() {\n    let (a, b, c, d, e);\n\n    (a, b) = (1, 2);\n    [c, .., d, _] = [1, 2, 3, 4, 5];\n    // ..表示中间元素被忽略，d匹配倒数第二个元素，_匹配最后一个元素5，但不绑定变量\n    Struct { e, .. } = Struct { e: 5 };\n    // e绑定结构体字段e的值5\n\n    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);\n}\n```\n- **变量与常量间的差异**\n    - 常量不允许用`mut`，它自始至终不可变\n    - 常量使用`const`关键字声明，且**必须**标注值的类型\n    - 常量可以在任意作用域内声明\n  示例：`const MAX_POINTS: u32 = 100_000`\n- **变量遮蔽**：Rust允许声明相同的变量名，后面生成的会遮蔽掉前面声明的，但是这两个变量是不同的。","x":-945,"y":-1100,"width":700,"height":960,"color":"4"},
		{"id":"1bb23ff1ca16ce18","type":"text","text":"## 所有权\n> [!cite] 编程语言设计中内存管理的流派\n> - **垃圾回收机制（GC）**：在程序允许时不断寻找不再使用的内存，典型的代表是`Java`和`Go`\n> - **手动管理内存的分配和释放**：在程序中，通过函数调用的方式来申请和释放内存，典型代表是`C++`\n> - **通过所有权来管理内存**：编译器在编译时会根据一系列规则进行检查\n\nRust选择的是第三种，这种检查只发生在编译期，在程序运行期没有任何性能损失。\n\n---\n\n### 所有权原则\n> [!important] 所有权规则\n> - Rust中每一个值都被一个变量所拥有，该变量称为值的所有者\n> - 一个值同时只能被一个变量所拥有\n> - 当所有者离开作用域范围时，这个值将被丢弃`drop`\n\n- 变量作用域：一个变量在程序中有效的范围。\n- 所有权转移（间接赋值操作）：\n    - 如果数据是基本数据，固定大小，那么会采用直接拷贝的形式；\n    - 但如果是复杂类型，存储在堆上，有**浅拷贝**和**深拷贝**两种选择，以`String`为例，浅拷贝就是只拷贝`String`本身（堆指针、字符串长度和字符串容量），深拷贝除了这些还要拷贝底层堆上的数据，深拷贝对性能的影响太大；\n    - Rust使用的类似于浅拷贝，但在拷贝后它会认为前一个变量不再有效，也就是将这块内存的所有权进行转移了，这个操作称作**移动**；\n- Rust不会自动创建数据的深拷贝，但我们可以通过`clone`来复制底层的内容\n- Rust 有一个叫做 `Copy` 的特征，如果一个类型拥有 `Copy` 特征，那么一个旧的变量在被赋值给其他变量后仍然可用。具有这一特征的类型有：\n    - 所有整数类型\n    - 布尔类型\n    - 所有浮点数类型\n    - 字符类型\n    - 元组\n    - 不可变引用`&T`\n- 函数传值与返回：将值传递给函数，也会发生**移动**或者**复制**。\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s 进入作用域\n\n    takes_ownership(s);             // s 的值移动到函数里 ...\n                                    // ... 所以到这里不再有效\n\n    let x = 5;                      // x 进入作用域\n\n    makes_copy(x);                  // x 应该移动函数里，\n                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x\n\n} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，\n  // 所以不会有特殊操作\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n    println!(\"{}\", some_string);\n} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n    println!(\"{}\", some_integer);\n} // 这里，some_integer 移出作用域。不会有特殊操作\n```\n    函数返回值也是同样：\n```rust\nfn main() {\n    let s1 = gives_ownership();         // gives_ownership 将返回值\n                                        // 移给 s1\n\n    let s2 = String::from(\"hello\");     // s2 进入作用域\n\n    let s3 = takes_and_gives_back(s2);  // s2 被移动到\n                                        // takes_and_gives_back 中,\n                                        // 它也将返回值移给 s3\n} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，\n  // 所以什么也不会发生。s1 移出作用域并被丢弃\n\nfn gives_ownership() -> String {             // gives_ownership 将返回值移动给\n                                             // 调用它的函数\n\n    let some_string = String::from(\"hello\"); // some_string 进入作用域.\n\n    some_string                              // 返回 some_string 并移出给调用的函数\n}\n\n// takes_and_gives_back 将传入字符串并返回该值\nfn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域\n\n    a_string  // 返回 a_string 并移出给调用的函数\n}\n```","x":1840,"y":-1260,"width":1040,"height":2140,"color":"1"},
		{"id":"0195d2ebb7c87467","type":"text","text":"## 前置知识\n### 不安全的代码示例\n```c\nint* foo() {\n    int a;          // 变量a的作用域开始\n    a = 100;\n    char *c = \"xyz\";   // 变量c的作用域开始\n    return &a;\n}                   // 变量a和c的作用域结束\n\n```\n这段代码中，`a`和`c`都是局部变量。\n`a`存在于栈中，函数结束后将`a`的地址返回，但离开作用域后`a`申请的栈上内存会被系统回收，从而造成**悬空指针Dangling Pointer**的问题。\n`c`是常量字符串，存储于常量区，只有当整个程序结束后系统才能回收这片内存。\n\n---\n### 栈和堆\n栈和堆是编程语言核心的数据结构，它的目标是为程序在运行时提供可供使用的内存空间。\n#### 栈\n栈中的所有数据必须占用已知且固定大小的内存空间。\n#### 堆\n大小未知或者可能变化的数据存储在堆上。\n当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**，该过程被称为**在堆上分配内存**，有时简称为**分配(allocating)**。\n接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，程序将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据。\n\n---\n\n### 性能区别、所有权与堆栈\n在栈上分配内存更快。当代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。","x":3120,"y":-2080,"width":720,"height":1080,"color":"#674c4c"},
		{"id":"8efdbfad9ca9d0c4","type":"text","text":"## 所有权与借用\nRust使用**所有权系统**来实现内存安全","x":1220,"y":-872,"width":360,"height":105,"color":"1"}
	],
	"edges":[
		{"id":"8532c11ce7786505","fromNode":"737b349daad0a249","fromSide":"top","toNode":"725fc9af7668037f","toSide":"left","color":"5"},
		{"id":"ca36e49d1e5fb841","fromNode":"737b349daad0a249","fromSide":"bottom","toNode":"691eae7cc7e633b0","toSide":"top","color":"5"},
		{"id":"a508aca7657057d5","fromNode":"737b349daad0a249","fromSide":"bottom","toNode":"922c3bb0d079703c","toSide":"top","color":"5"},
		{"id":"d4b321434edc263e","fromNode":"737b349daad0a249","fromSide":"right","toNode":"d8054fe6afb00f93","toSide":"left","color":"5"},
		{"id":"d1dea1792a3d07ed","fromNode":"e6b35e9fef1bd8e2","fromSide":"right","toNode":"737b349daad0a249","toSide":"left","color":"4"},
		{"id":"7fce253348d21182","fromNode":"8efdbfad9ca9d0c4","fromSide":"right","toNode":"1bb23ff1ca16ce18","toSide":"left","color":"1"},
		{"id":"6a9865f9d6be02a2","fromNode":"1bb23ff1ca16ce18","fromSide":"top","toNode":"0195d2ebb7c87467","toSide":"left","color":"#674c4c"}
	]
}