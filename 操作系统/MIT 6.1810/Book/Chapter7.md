# Scheduling

ä»»ä½•æ“ä½œç³»ç»Ÿéƒ½å¯èƒ½è¿è¡Œæ¯”è®¡ç®—æœºæœ‰çš„CPUæ›´å¤šçš„è¿›ç¨‹ï¼Œå› æ­¤éœ€è¦ä¸€ä¸ªè®¡åˆ’æ¥åœ¨è¿›ç¨‹é—´åˆ†æ—¶å…±äº«CPUã€‚ä¸€ç§å¸¸è§çš„æ–¹æ³•æ˜¯å°†è¿›ç¨‹å¤šè·¯å¤ç”¨åˆ°ç¡¬ä»¶CPUä¸Šï¼Œä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›æ‹¥æœ‰è‡ªå·±è™šæ‹ŸCPUçš„å‡è±¡ã€‚

---

## Multiplexing

## å¤šè·¯å¤ç”¨

`xv6`é€šè¿‡åœ¨ä¸¤ç§æƒ…å†µä¸‹å°†æ¯ä¸ªCPUä»ä¸€ä¸ªè¿›ç¨‹åˆ‡æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹æ¥è¿›è¡Œå¤šè·¯å¤ç”¨ã€‚é¦–å…ˆï¼Œ`sleep`å’Œ`wakeup`æœºåˆ¶ä¼šåœ¨è¿›ç¨‹ç­‰å¾…è®¾å¤‡æˆ–ç®¡é“I/Oå®Œæˆã€ç­‰å¾…å­è¿›ç¨‹é€€å‡ºæˆ–åœ¨`sleep`ç³»ç»Ÿè°ƒç”¨ä¸­ç­‰å¾…æ—¶è¿›è¡Œåˆ‡æ¢ï¼›å…¶æ¬¡ï¼Œ`xv6`å®šæœŸå¼ºåˆ¶åˆ‡æ¢ä»¥å¤„ç†é•¿æ—¶é—´ä¸è®¡ç®—ä¸”ä¸ç¡çœ çš„è¿›ç¨‹ã€‚

å¤šè·¯å¤ç”¨çš„å®ç°éœ€è¦è€ƒè™‘å¤šä¸ªé—®é¢˜ï¼š
- å¦‚ä½•ä»ä¸€ä¸ªè¿›ç¨‹åˆ‡æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ï¼Ÿ
- å¦‚ä½•ä»¥å¯¹ç”¨æˆ·è¿›ç¨‹é€æ˜çš„æ–¹å¼å¼ºåˆ¶åˆ‡æ¢ï¼Ÿ
- è®¸å¤šCPUå¯èƒ½åŒæ—¶åœ¨ä¸åŒè¿›ç¨‹é—´åˆ‡æ¢ï¼Œéœ€è¦ä¸€ä¸ªé”æ¥é¿å…ç«äº‰ï¼›
- è¿›ç¨‹é€€å‡ºæ—¶éœ€é‡Šæ”¾å…¶å†…å­˜å’Œå…¶ä»–èµ„æºï¼Œä½†éœ€è¦å¤–éƒ¨å®Œæˆï¼›
- å¤šæ ¸æœºå™¨çš„æ¯ä¸ªæ ¸å¿ƒå¿…é¡»è®°ä½å®ƒåœ¨æ‰§è¡Œå“ªä¸ªè¿›ç¨‹ï¼›
- `sleep`å’Œ`wakeup`å…è®¸ä¸€ä¸ªè¿›ç¨‹æ”¾å¼ƒCPUå¹¶ç¡çœ ç­‰å¾…äº‹ä»¶ï¼Œå¹¶å…è®¸å¦ä¸€ä¸ªè¿›ç¨‹å”¤é†’è¯¥è¿›ç¨‹ï¼Œä½†éœ€å°å¿ƒé¿å…ä¼šå¯¼è‡´å”¤é†’é€šçŸ¥ä¸¢å¤±çš„ç«äº‰ã€‚
![[Pasted image 20250528134153.png]]

---

## Codeï¼šContext switching

ä¸Šå›¾æ¦‚è¿°äº†ä»ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹åˆ‡æ¢åˆ°å¦ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ‰€æ¶‰åŠçš„æ­¥éª¤ï¼š
- é¦–å…ˆé€šè¿‡ç³»ç»Ÿè°ƒç”¨æˆ–è€…ä¸­æ–­ï¼Œä»ç”¨æˆ·ç©ºé—´è½¬æ¢åˆ°æ—§è¿›ç¨‹çš„å†…æ ¸ç©ºé—´ï¼›
- ç„¶åä¸Šä¸‹æ–‡åˆ‡æ¢åˆ°å½“å‰CPUçš„è°ƒåº¦å™¨çº¿ç¨‹ï¼›
- å†åˆ‡æ¢åˆ°æ–°è¿›ç¨‹çš„å†…æ ¸çº¿ç¨‹ï¼›
- æœ€å`trap`è¿”å›åˆ°ç”¨æˆ·ç©ºé—´ã€‚

`xv6`è°ƒåº¦å™¨ä¸ºæ¯ä¸ªCPUéƒ½æœ‰ä¸€ä¸ªä¸“ç”¨çº¿ç¨‹ï¼ˆæœ‰ä¿å­˜çš„å¯„å­˜å™¨å’Œå †æ ˆï¼‰ã€‚åœ¨æ—§è¿›ç¨‹çš„å†…æ ¸å †æ ˆä¸Šæ‰§è¡Œè°ƒåº¦å™¨ä¸å®‰å…¨ï¼Œå› ä¸ºå…¶ä»–æ ¸å¿ƒä¹Ÿå¯èƒ½å”¤é†’è¯¥è¿›ç¨‹å¹¶è¿è¡Œï¼Œè¿™å°†å¯¼è‡´åœ¨ä¸åŒçš„æ ¸å¿ƒä¸Šä½¿ç”¨ç›¸åŒçš„å †æ ˆã€‚

å¦å¤–ï¼Œåˆ‡æ¢çº¿ç¨‹è¿˜æ¶‰åŠåˆ°ä¿å­˜æ—§çº¿ç¨‹çš„CPUå¯„å­˜å™¨ï¼Œä»¥åŠæ¢å¤æ–°è¿›ç¨‹ä¹‹å‰ä¿å­˜çš„å¯„å­˜å™¨ã€‚æ¢å¤æ ˆæŒ‡é’ˆå’Œç¨‹åºè®¡æ•°å™¨å°±æ„å‘³ç€CPUå°†åˆ‡æ¢æ ˆå¹¶åˆ‡æ¢å®ƒæ­£åœ¨æ‰§è¡Œçš„ä»£ç ã€‚å‡½æ•°`swtch`è´Ÿè´£æ‰§è¡Œå†…æ ¸çº¿ç¨‹åˆ‡æ¢çš„ä¿å­˜å’Œæ¢å¤æ“ä½œï¼Œå®ƒä¼šä¿å­˜å’Œæ¢å¤å¯„å­˜å™¨é›†ï¼ˆç§°ä¸ºä¸Šä¸‹æ–‡ï¼‰ã€‚å½“ä¸€ä¸ªè¿›ç¨‹éœ€è¦è®©å‡ºCPUæ—¶ï¼Œå®ƒçš„å†…æ ¸çº¿ç¨‹ä¼šè°ƒç”¨`swtch`æ¥ä¿å­˜è‡ªå·±çš„ä¸Šä¸‹æ–‡å¹¶è¿”å›åˆ°è°ƒåº¦å™¨ä¸Šä¸‹æ–‡ã€‚æ¯ä¸ªä¸Šä¸‹æ–‡éƒ½åŒ…å«åœ¨ä¸€ä¸ª`struct context`ä¸­ï¼Œè€Œå®ƒæœ¬èº«åˆåŒ…å«åœ¨è¿›ç¨‹çš„`struct proc`ä¸­æˆ– CPU çš„`struct cpu`ä¸­ã€‚

```c
// Saved registers for kernel context switches.
struct context {
  uint64 ra;
  uint64 sp;

  // callee-saved
  uint64 s0;
  uint64 s1;
  uint64 s2;
  uint64 s3;
  uint64 s4;
  uint64 s5;
  uint64 s6;
  uint64 s7;
  uint64 s8;
  uint64 s9;
  uint64 s10;
  uint64 s11;
};

// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
```

`swtch`æ¥æ”¶ä¸¤ä¸ªå‚æ•°`struct context *old`å’Œ`struct context *new`ã€‚å®ƒå°†å½“å‰å¯„å­˜å™¨ä¿å­˜åˆ°`old`ä¸­ï¼Œå†ä»`new`ä¸­åŠ è½½å¯„å­˜å™¨ï¼Œç„¶åè¿”å›ã€‚

ç°åœ¨å‡æƒ³è·Ÿéšä¸€ä¸ªè¿›ç¨‹é€šè¿‡`swtch`è¿›å…¥è°ƒåº¦ç¨‹åºã€‚ä¸­æ–­ç»“æŸæ—¶çš„ä¸€ç§å¯èƒ½æ˜¯`usertrap`è°ƒç”¨`yield`ï¼Œç„¶å`yield`è°ƒç”¨`sched`ï¼Œ`sched`è°ƒç”¨`swtch`å°†å½“å‰ä¸Šä¸‹æ–‡ä¿å­˜åˆ°`p->context`ä¸­ï¼Œå¹¶åˆ‡æ¢åˆ°ä¹‹å‰ä¿å­˜çš„è°ƒåº¦ç¨‹åºä¸Šä¸‹æ–‡ã€‚

```c
// Switch to scheduler.  Must hold only p->lock
// and have changed proc->state. Saves and restores
// intena because intena is a property of this
// kernel thread, not this CPU. It should
// be proc->intena and proc->noff, but that would
// break in the few places where a lock is held but
// there's no process.
void
sched(void)
{
  int intena;
  struct proc *p = myproc();

  if(!holding(&p->lock))
    panic("sched p->lock");
  if(mycpu()->noff != 1)
    panic("sched locks");
  if(p->state == RUNNING)
    panic("sched running");
  if(intr_get())
    panic("sched interruptible");

  intena = mycpu()->intena;
  swtch(&p->context, &mycpu()->context);
  mycpu()->intena = intena;
}

// Give up the CPU for one scheduling round.
void
yield(void)
{
  struct proc *p = myproc();
  acquire(&p->lock);
  p->state = RUNNABLE;
  sched();
  release(&p->lock);
}
```

`swtch`å‡½æ•°è‡ªèº«ï¼ˆè¢«è°ƒç”¨è€…ï¼‰ä»…ä¿å­˜*Callee-saved registers*ï¼Œ*Caller-saved registers*ç”±è°ƒç”¨å‡½æ•°ï¼ˆè°ƒç”¨è€…ï¼‰è´Ÿè´£ä¿å­˜å’Œæ¢å¤ï¼Œå³å¦‚æœæœ‰éœ€è¦ä¿å­˜çš„å€¼ï¼Œéœ€è¦åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰å°†è¿™äº›å¯„å­˜å™¨çš„å€¼å‹å…¥æ ˆä¸­ï¼Œå¹¶åœ¨è°ƒç”¨è¿”å›åæ¢å¤ã€‚

> [!faq] è´£ä»»åˆ’åˆ†æœºåˆ¶
> å‡è®¾æœ‰ä»¥ä¸‹Cä»£ç è°ƒç”¨å…³ç³»ï¼š
> ```c
> void funcA() { 
>    int x = 10; 
>    funcB(); // è°ƒç”¨funcB 
>    // æ­¤æ—¶éœ€è¦ç¡®ä¿xçš„å€¼ä»ç„¶æ˜¯10 
> } 
> void funcB() { 
>    // funcBå¯èƒ½ä¼šä¿®æ”¹caller-savedå¯„å­˜å™¨
> }
> ```
> - å¯„å­˜å™¨ä¿å­˜æµç¨‹ï¼š
 >   1. `funcA`åœ¨è°ƒç”¨`funcB`å‰ï¼Œè‹¥éœ€è¦ä¿ç•™æŸäº› caller-saved å¯„å­˜å™¨ï¼ˆå¦‚`eax`ï¼‰ï¼Œåˆ™å°†å…¶å‹æ ˆã€‚
 >   2. è°ƒç”¨`funcB`ï¼Œ`funcB`æ— éœ€å…³å¿ƒ caller-saved å¯„å­˜å™¨çš„åŸå§‹å€¼ã€‚
 >   3. `funcB`åœ¨æ‰§è¡Œå‰ä¿å­˜ callee-saved å¯„å­˜å™¨ï¼ˆå¦‚`ebp`ï¼‰ï¼Œæ‰§è¡Œåæ¢å¤è¿™äº›å¯„å­˜å™¨ã€‚
 >   4. `funcB`è¿”å›åï¼Œ`funcA`ä»æ ˆä¸­æ¢å¤ caller-saved å¯„å­˜å™¨çš„å€¼ã€‚
> - è¿™ç§åˆ†å·¥çš„ä¸»è¦ç›®çš„æ˜¯ä¼˜åŒ–æ€§èƒ½ï¼š
>     - Callee-saved å¯„å­˜å™¨é€šå¸¸ç”¨äºä¿å­˜å‡½æ•°å†…éƒ¨çš„é•¿æœŸçŠ¶æ€ï¼ˆå¦‚å±€éƒ¨å˜é‡ï¼‰ï¼Œå› æ­¤ç”±è¢«è°ƒç”¨è€…ç®¡ç†æ›´é«˜æ•ˆã€‚
>     - Caller-saved å¯„å­˜å™¨å¸¸ç”¨äºçŸ­æœŸæ•°æ®ä¼ é€’ï¼ˆå¦‚å‡½æ•°å‚æ•°ï¼‰ï¼Œè°ƒç”¨è€…å¯ä»¥æ›´çµæ´»åœ°å†³å®šæ˜¯å¦éœ€è¦ä¿å­˜è¿™äº›å€¼ã€‚

`swtch`çŸ¥é“æ¯ä¸ªå¯„å­˜å™¨å­—æ®µåœ¨`struct context`ä¸­çš„åç§»é‡ï¼Œå®ƒä¸ä¿å­˜ç¨‹åºè®¡æ•°å™¨ï¼Œä½†ä¿å­˜`ra`å¯„å­˜å™¨ï¼Œè¯¥å¯„å­˜å™¨å­˜æœ‰è°ƒç”¨`swtch`çš„è¿”å›åœ°å€ã€‚

```assembly
swtch:
        # ä¿å­˜å½“å‰è¿›ç¨‹çš„ä¸Šä¸‹æ–‡åˆ° p->context
        sd ra, 0(a0)      # ä¿å­˜è¿”å›åœ°å€
        sd sp, 8(a0)      # ä¿å­˜æ ˆæŒ‡é’ˆ
        sd s0, 16(a0)     # ä¿å­˜ callee-saved å¯„å­˜å™¨
        sd s1, 24(a0)
        # ... å…¶ä»–å¯„å­˜å™¨
        
        # åŠ è½½è°ƒåº¦å™¨çš„ä¸Šä¸‹æ–‡ cpu->context  
        ld ra, 0(a1)      # åŠ è½½è¿”å›åœ°å€
        ld sp, 8(a1)      # åŠ è½½æ ˆæŒ‡é’ˆ
        ld s0, 16(a1)     # åŠ è½½ callee-saved å¯„å­˜å™¨
        ld s1, 24(a1)
        # ... å…¶ä»–å¯„å­˜å™¨
        
        ret               # è¿”å›åˆ° ra æŒ‡å‘çš„åœ°å€
```

`swtch`ä¼šä»æ–°çš„ä¸Šä¸‹æ–‡ä¸­æ¢å¤å¯„å­˜å™¨ï¼Œè¿™äº›å¯„å­˜å™¨ä¿å­˜äº†ä¹‹å‰`swtch`ä¿å­˜çš„å¯„å­˜å™¨å€¼ã€‚å½“`swtch`è¿”å›æ—¶ï¼Œå®ƒè¿”å›åˆ°æ¢å¤çš„`ra`å¯„å­˜å™¨æŒ‡å‘çš„æŒ‡ä»¤ï¼Œå³è¿”å›åˆ°è°ƒç”¨`swtch`çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚ä¸è¿‡ï¼Œå®ƒä¼šåœ¨æ–°çº¿ç¨‹çš„æ ˆä¸Šè¿”å›ã€‚

```c
// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns.  It loops, doing:
//  - choose a process to run.
//  - swtch to start running that process.
//  - eventually that process transfers control
//    via swtch back to the scheduler.
void
scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();

  c->proc = 0;
  for(;;){
    // The most recent process to run may have had interrupts
    // turned off; enable them to avoid a deadlock if all
    // processes are waiting.
    intr_on();

    int found = 0;
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        // Switch to chosen process.  It is the process's job
        // to release its lock and then reacquire it
        // before jumping back to us.
        p->state = RUNNING;
        c->proc = p;
        swtch(&c->context, &p->context);

        // Process is done running for now.
        // It should have changed its p->state before coming back.
        c->proc = 0;
        found = 1;
      }
      release(&p->lock);
    }
    if(found == 0) {
      // nothing to run; stop running on this core until an interrupt.
      intr_on();
      asm volatile("wfi");
    }
  }
}
```

åœ¨è¿™ä¸ªæµç¨‹ä¸­ï¼Œå•ç‹¬å†æ¥çœ‹çœ‹è¿”å›åœ°å€çš„å¤„ç†ï¼š
1. ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼š`swtch(&p->context, &mycpu->context)`ï¼š
   - ä¿å­˜å½“å‰è¿›ç¨‹çš„`ra`ï¼ˆæŒ‡å‘`sched()`ä¸­`swtch`çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰
   - åŠ è½½è°ƒåº¦å™¨çš„`ra`ï¼ˆæŒ‡å‘`scheduler()`ä¸­`swtch`çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰
   - è¿”å›åˆ°è°ƒåº¦å™¨ç»§ç»­æ‰§è¡Œ
1. ç¬¬äºŒæ¬¡è°ƒç”¨ï¼š`swtch(&c->context, &p->context)`ï¼š
   - ä¿å­˜è°ƒåº¦å™¨çš„`ra`ï¼ˆæŒ‡å‘`scheduler()`ä¸­`swtch`çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰
   - åŠ è½½è¿›ç¨‹çš„`ra`ï¼ˆæŒ‡å‘`sched()`ä¸­`swtch`çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰
   - è¿”å›åˆ°è¿›ç¨‹çš„`sched()`ç»§ç»­æ‰§è¡Œ

```text
è¿›ç¨‹Aæ‰§è¡Œä¸­
    â†“
yield() 
    â†“
sched()
    â†“
swtch(&p->context, &mycpu()->context)  â†’ ä¿å­˜è¿›ç¨‹Aä¸Šä¸‹æ–‡ï¼ŒåŠ è½½è°ƒåº¦å™¨ä¸Šä¸‹æ–‡
    â†“                                    
scheduler() çš„ swtch è¿”å›ç‚¹              â† è·³è½¬åˆ°è¿™é‡Œ
    â†“
è°ƒåº¦å™¨å¯»æ‰¾å¯è¿è¡Œè¿›ç¨‹B
    â†“
swtch(&c->context, &p->context)        â†’ ä¿å­˜è°ƒåº¦å™¨ä¸Šä¸‹æ–‡ï¼ŒåŠ è½½è¿›ç¨‹Bä¸Šä¸‹æ–‡
    â†“
è¿›ç¨‹Bçš„ sched() ä¸­çš„ swtch è¿”å›ç‚¹        â† è·³è½¬åˆ°è¿™é‡Œ
    â†“
è¿›ç¨‹Bä»yield()è¿”å›ï¼Œç»§ç»­æ‰§è¡Œ
```

> [!faq] FAQ
> - è¿”å›ç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ
>   è¿™é‡Œçš„è¿”å›ç‚¹ä¸æ˜¯å‡½æ•°è¿”å›ï¼Œè€Œæ˜¯æŒ‡ä»¤æ‰§è¡Œä½ç½®çš„æ¢å¤ï¼Œå³`ra`å¯„å­˜å™¨æŒ‡å‘çš„åœ°å€ã€‚æ¯”å¦‚è¿›ç¨‹è°ƒç”¨`sched()`ï¼š
>   ```c
>   // åœ¨sched()å‡½æ•°ä¸­ï¼ˆç¬¬503è¡Œï¼‰
>   intena = mycpu()->intena;
>   swtch(&p->context, &mycpu()->context);  // â† è°ƒç”¨ä½ç½®
>   mycpu()->intena = intena;               // â† è¿™é‡Œæ˜¯"è¿”å›ç‚¹"ï¼
>   ```
>   å½“è¿›ç¨‹æ‰§è¡Œåˆ°Â swtchÂ è°ƒç”¨æ—¶ï¼š
>   1. è°ƒç”¨æŒ‡ä»¤æ‰§è¡Œå‰ï¼š`ra`å¯„å­˜å™¨è¢«è‡ªåŠ¨è®¾ç½®ä¸ºç¬¬504è¡Œçš„åœ°å€
>   2. `swtch`ä¿å­˜ä¸Šä¸‹æ–‡ï¼šå°†è¿™ä¸ª`ra`å€¼ä¿å­˜åˆ°`p->context.ra`
>   3. åŠ è½½è°ƒåº¦å™¨ä¸Šä¸‹æ–‡ï¼šä»`mycpu()->context.ra`åŠ è½½æ–°çš„`ra`
>   4. `ret`æŒ‡ä»¤æ‰§è¡Œï¼šè·³è½¬åˆ°æ–°`ra`æŒ‡å‘çš„åœ°å€
> - `mycpu()->context`ä¸ºä»€ä¹ˆæ˜¯è°ƒåº¦å™¨ä¸Šä¸‹æ–‡ï¼Ÿ
>   æŸ¥çœ‹`main()`å‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°æ¯ä¸ªCPUæ ¸å¿ƒåœ¨å¯åŠ¨æ—¶éƒ½ç›´æ¥è°ƒç”¨äº†`scheduler()`ï¼š
>   ```c
>   void main() {
>     // ... å„ç§åˆå§‹åŒ–
>     scheduler();  // ç›´æ¥è°ƒç”¨ï¼Œæ°¸ä¸è¿”å›
>   }
>   ```
>   æ•…è€Œè°ƒåº¦å™¨æ˜¯åœ¨CPUçš„åŸå§‹ä¸Šä¸‹æ–‡ä¸­å¼€å§‹è¿è¡Œçš„ï¼Œå®ƒçš„æ ˆåœ¨å†…æ ¸æ ˆä¸­ã€‚
> - `scheduler()`çš„`swtch`è¿”å›ç‚¹
>   ```c
>   c->proc = 0;
>   found = 1;
>   ```
> - è¿›ç¨‹Bçš„`sched()`ä¸­çš„`swtch`è¿”å›ç‚¹
>   è¿™é‡Œçš„å…³é”®åœ¨äºï¼š**è¿›ç¨‹Bä¸æ˜¯ç¬¬ä¸€æ¬¡è¿è¡Œï¼**
>   å¯ä»¥æŸ¥çœ‹`proc.c`ä¸­æ–°è¿›ç¨‹çš„åˆå§‹åŒ–ï¼š
>   ```c
>   // Set up new context to start executing at forkret
>   memset(&p->context, 0, sizeof(p->context));
>   p->context.ra = (uint64)forkret;  // æ–°è¿›ç¨‹ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶ä¼šåˆ°forkret
>   p->context.sp = p->kstack + PGSIZE;
>   ```
>   è¿›ç¨‹Bç¬¬ä¸€æ¬¡è¢«è°ƒåº¦æ˜¯ä»`forkret`å¼€å§‹æ‰§è¡Œã€‚ç„¶ååœ¨åç»­çš„æŸä¸ªæ—¶åˆ»å®ƒè°ƒç”¨`yield()->sched()->swtch()`è®©å‡ºCPUï¼Œè€Œç°åœ¨è°ƒåº¦å™¨é‡æ–°é€‰ä¸­è¿›ç¨‹Bï¼Œ`swtch`å°†è¿”å›åˆ°è¿›ç¨‹Båœ¨`sched()`ä¸­çš„è¿”å›ç‚¹ï¼Œä¹Ÿå³é—®é¢˜1ä¸­é‚£ä¸ªä¾‹å­çš„ä½ç½®ã€‚

ç¡®å®ç²¾å¦™ï¼è¿™å‡ ä¸ªå‡½æ•°ä¹‹é—´çš„å…³ç³»ã€‚

---

## Codeï¼šScheduling

ä¸Šä¸€èŠ‚è®¨è®ºäº†`swtch`çš„å·¥ä½œç»†èŠ‚ï¼Œåœ¨è¿™ä¸€èŠ‚ä¸­åªéœ€è¦å°†`swtch`æŠ½è±¡ä¸€ä¸‹å³å¯ï¼Œä¸»è¦ç ”ç©¶ä»ä¸€ä¸ªè¿›ç¨‹çš„å†…æ ¸çº¿ç¨‹é€šè¿‡è°ƒåº¦å™¨åˆ‡æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹çš„è¿‡ç¨‹ã€‚

è°ƒåº¦å™¨çš„å­˜åœ¨å½¢å¼æ˜¯æ¯ä¸ªCPUä¸­çš„ä¸€ä¸ªç‰¹æ®Šçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½ä¼šè¿è¡Œè°ƒåº¦å™¨å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šè´Ÿè´£é€‰æ‹©æ¥ä¸‹æ¥è¦è¿è¡Œçš„è¿›ç¨‹ã€‚ä»»ä½•æƒ³æ”¾å¼ƒCPUçš„è¿›ç¨‹å¿…é¡»è·å–è‡ªå·±çš„è¿›ç¨‹é”`p->lock`ï¼Œç„¶åé‡Šæ”¾å®ƒæŒæœ‰çš„ä»»ä½•å…¶ä»–é”ï¼Œå¹¶æ›´æ–°è‡ªå·±çš„çŠ¶æ€`p->state`ï¼Œè°ƒç”¨`sched`ã€‚`yield()`ã€`sleep()`å’Œ`exit()`è¿™äº›å‡½æ•°éƒ½éµå¾ªè¿™ä¸€æ­¥éª¤ã€‚è¿™äº›åœ¨`sched`ä¸­ä¹Ÿä¼šå†æ¬¡æ£€æŸ¥ã€‚

ç„¶åå› ä¸ºæŒæœ‰é”ï¼Œä¸­æ–­ä¼šè¢«ç¦ç”¨ã€‚æœ€åï¼Œ`sched`è°ƒç”¨`swtch`å°†å½“å‰ä¸Šä¸‹æ–‡ä¿å­˜åœ¨`p->context`ä¸­ï¼Œå¹¶åˆ‡æ¢åˆ°`cpu->scheduler`ä¸­çš„è°ƒåº¦å™¨ä¸Šä¸‹æ–‡ã€‚`swtch`åœ¨è°ƒåº¦å™¨çš„æ ˆä¸Šè¿”å›ï¼Œè°ƒåº¦å™¨å¯»æ‰¾è¦è¿è¡Œçš„è¿›ç¨‹ï¼Œç„¶ååˆ‡æ¢ã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ`xv6`åœ¨è°ƒç”¨`swtch`æ—¶æŒæœ‰`p->lock`ï¼Œ`swtch`çš„è°ƒç”¨è€…å¿…é¡»å·²ç»æŒæœ‰é”ï¼Œå¹¶ä¸”é”çš„æ§åˆ¶æƒä¼šä¼ é€’ç»™åˆ‡æ¢åˆ°çš„ä»£ç ã€‚è¿™å¹¶ä¸å¸¸è§ï¼Œå› ä¸ºå¤§å¤šæ•°è·å–é”çš„çº¿ç¨‹ä¹Ÿä¼šè´Ÿè´£é‡Šæ”¾é”ã€‚ä¸è¿‡åœ¨ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸­ï¼Œå› ä¸ºé”ä¿æŠ¤çš„è¿›ç¨‹çŠ¶æ€å’Œä¸Šä¸‹æ–‡å­—æ®µçš„ä¸å˜é‡å¹¶ä¸æˆç«‹ï¼Œå› æ­¤è¿™æ ·æ˜¯å¿…è¦çš„ã€‚å¦åˆ™å¯èƒ½å‡ºç°ï¼šåœ¨`yield()`å°†è¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸º`RUNNABLE`ä¹‹åï¼Œä½†åœ¨`swtch`å¯¼è‡´å®ƒåœç”¨è‡ªå·±çš„å†…æ ¸æ ˆå‰ï¼Œå¦ä¸€ä¸ªCPUå†³å®šè¿è¡Œè¯¥è¿›ç¨‹ï¼Œè¿™æ ·å°±ä¼šå‡ºç°é”™è¯¯ã€‚

åœ¨`xv6`ä¸­ï¼Œå†…æ ¸çº¿ç¨‹æ€»æ˜¯é€šè¿‡`sched()`å‡½æ•°ä¸­çš„`swtch()`ä¸€è¡Œè®©å‡ºCPUï¼Œåˆæ€»æ˜¯æ¢å¤äºä¸‹ä¸€è¡Œï¼›è€Œè°ƒåº¦å™¨æ€»æ˜¯åœ¨`scheduler()`å‡½æ•°çš„`c->proc=p`ä¸€è¡Œè®©æ­¥ï¼Œåˆåœ¨`swtch()`ä¸€è¡Œæ¢å¤ã€‚

```text
è°ƒåº¦å™¨åç¨‹ (scheduler)                 è¿›ç¨‹åç¨‹ (sched)
     â”‚                                      â”‚
     â”œâ”€ ç¬¬465è¡Œ: swtch(&c->context, &p->context)
     â”‚              â”‚                       â”‚
     â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚
     â”‚                                      â”‚
     â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æš‚åœåœ¨ç¬¬466è¡Œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ ç¬¬505è¡Œ: swtch(&p->context, &mycpu()->context)
     â”‚                                      â”‚              â”‚
     â”‚                                      â”‚              â”‚
     â”‚  ç¬¬466è¡Œæ¢å¤: c->proc = 0; â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                      â”‚
     â”‚              (å¯»æ‰¾ä¸‹ä¸€ä¸ªè¿›ç¨‹)          â”‚ æš‚åœåœ¨ç¬¬506è¡Œ
     â”‚                                      â”‚
     â”œâ”€ å†æ¬¡ç¬¬465è¡Œ: swtch(...) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚ ç¬¬506è¡Œæ¢å¤: mycpu()->intena = intena;
     â”‚                                      â”‚
```

> [!info] *coroutines*
> è¿™ç§åœ¨ä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´è¿›è¡Œé£æ ¼åŒ–åˆ‡æ¢çš„è¿‡ç¨‹æœ‰æ—¶è¢«ç§°ä¸ºåç¨‹ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ`sched`å’Œ`scheduler`å°±æ˜¯å½¼æ­¤çš„åç¨‹ã€‚

ä¸è¿‡æœ‰ä¸€ç§æƒ…å†µï¼Œè°ƒåº¦å™¨è°ƒç”¨`swtch`ä¸ä¼šåœ¨`sched`ä¸­ç»“æŸã€‚å½“ä¸€ä¸ªæ–°è¿›ç¨‹é¦–æ¬¡è¢«è°ƒåº¦æ—¶ï¼Œå®ƒä»`forkret`å¼€å§‹ã€‚`forkret`çš„å­˜åœ¨æ˜¯ä¸ºäº†é‡Šæ”¾`p->lock`ï¼Œå¦åˆ™ï¼Œæ–°è¿›ç¨‹å¯ä»¥ä»`usertrapret`å¼€å§‹ã€‚

> [!faq] å…³äº`forkret`
> å®ƒçš„å…³é”®ä½œç”¨åœ¨äºå¤„ç†é”çš„æ‰€æœ‰æƒè½¬ç§»ã€‚
> åœ¨`scheduler()`å‡½æ•°ä¸­ï¼š
> ```c
> for(p = proc; p < &proc[NPROC]; p++) {
> acquire(&p->lock);                    // â­ è°ƒåº¦å™¨è·å–è¿›ç¨‹é”
> if(p->state == RUNNABLE) {
>   p->state = RUNNING;
>   c->proc = p;
>   swtch(&c->context, &p->context);    // â­ åˆ‡æ¢åˆ°è¿›ç¨‹ï¼Œä½†é”ä»è¢«æŒæœ‰ï¼
> ```
> è°ƒåº¦å™¨åœ¨åˆ‡æ¢åˆ°è¿›ç¨‹ä¹‹å‰è·å–äº†é”ï¼Œç„¶ååœ¨`swtch`åï¼Œé”çš„æ‰€æœ‰æƒè½¬ç§»ç»™äº†æ–°è¿›ç¨‹ã€‚
> æ–°è¿›ç¨‹åœ¨ç¬¬ä¸€æ¬¡è°ƒåº¦å‰çš„åˆå§‹åŒ–å‰é¢ä¹Ÿè¯´åˆ°äº†ï¼Œä¼šåœ¨`forkret`å¼€å§‹æ‰§è¡Œï¼Œä½†æ˜¯ç»§æ‰¿äº†è°ƒåº¦å™¨æŒæœ‰çš„`p->lock`ã€‚
> ```c
> // A fork child's very first scheduling by scheduler()
> // will swtch to forkret.
> void
> forkret(void)
> {
> Â  static int first = 1;
>  
> Â  // Still holding p->lock from scheduler.
>Â   release(&myproc()->lock);
>  
> Â  if (first) {
> Â  Â  // File system initialization must be run in the context of a
> Â  Â  // regular process (e.g., because it calls sleep), and thus cannot
> Â  Â  // be run from main().
> Â  Â  fsinit(ROOTDEV);
>  
> Â  Â  first = 0;
> Â  Â  // ensure other cores see first=0.
> Â  Â  __sync_synchronize();
> }
> ```
> åœ¨`forkret`ä¸­æœ‰é‡Šæ”¾æ“ä½œã€‚å¦‚æœç›´æ¥ä»`usertrapret()`å¼€å§‹ï¼Œè¿”å›ç”¨æˆ·ç©ºé—´å¹¶æ‰§è¡Œç¨‹åºï¼Œé‚£å°±å¯èƒ½æœ‰æ­»é”ã€è°ƒåº¦å™¨é˜»å¡ç­‰ç­‰é£é™©ã€‚

è°ƒåº¦ç¨‹åºè¿è¡Œå¾ªç¯éå†è¿›ç¨‹è¡¨ï¼Œå¯»æ‰¾ä¸€ä¸ªå¯è¿è¡Œçš„ç¨‹åºï¼Œå³`p->state == RUNNABLE`ã€‚ä¸€æ—¦æ‰¾åˆ°ï¼Œå®ƒå°±ä¼šè®¾ç½®æ¯ä¸ªCPUçš„å½“å‰è¿›ç¨‹å˜é‡`c->proc`ï¼Œå°†è¿›ç¨‹æ ‡è®°ä¸º`RUNNING`ï¼Œç„¶åè°ƒç”¨`swtch`å¼€å§‹è¿è¡Œã€‚

ä¹Ÿå¯ä»¥ä»ä¸å˜é‡çš„è§’åº¦æ¥æ€è€ƒè°ƒåº¦ä»£ç çš„ç»“æ„ä¸é¡ºåºï¼Œå®ƒå¼ºåˆ¶æŒ‡å‘å…³äºæ¯ä¸ªè¿›ç¨‹çš„ä¸€ç»„ä¸å˜é‡ï¼Œå¹¶åœ¨è¿™äº›ä¸å˜é‡ä¸æˆç«‹æ—¶ç«‹å³æŒæœ‰`p->lock`ã€‚

> [!info] *invariants*
> ä¸å˜é‡æ˜¯ç³»ç»Ÿå¿…é¡»å§‹ç»ˆæ»¡è¶³çš„æ¡ä»¶ï¼Œåœ¨`xv6`ä¸­ï¼Œæ¯ä¸ªè¿›ç¨‹çŠ¶æ€éƒ½å¯¹åº”ç‰¹å®šçš„ä¸å˜é‡ï¼Œå½“è¿™äº›æ¡ä»¶è¢«æš‚æ—¶ç ´åæ—¶ï¼Œå¿…é¡»æŒæœ‰`p->lock`æ¥é˜²æ­¢å¹¶å‘è®¿é—®ã€‚

æ¯”å¦‚`RUNNING`çŠ¶æ€å°±æ˜¯ä¸€ä¸ªä¸å˜é‡ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹æ˜¯`RUNNING`çŠ¶æ€ï¼Œå®šæ—¶å™¨ä¸­æ–­çš„`yield()`å¿…é¡»èƒ½å®‰å…¨åœ°åˆ‡æ¢èµ°è¯¥è¿›ç¨‹ã€‚è¿™æ„å‘³ç€åœ¨æ­¤åˆ»ï¼ŒCPUå¯„å­˜å™¨å¿…é¡»ä¿å­˜æœ‰è¯¥è¿›ç¨‹çš„å¯„å­˜å™¨å€¼ï¼ˆå³`swtch`è¿˜æ²¡æœ‰å°†å®ƒä»¬ç§»åŠ¨åˆ°`context`ä¸­ï¼‰ï¼Œä¸”`c->proc`å¿…é¡»æŒ‡å‘è¯¥è¿›ç¨‹ã€‚ä»£ç ä½“ç°åœ¨`scheduler()`ï¼š

```c
p->state = RUNNING;
// âš ï¸ å¦‚æœè¿™é‡Œå‘ç”Ÿæ—¶é’Ÿä¸­æ–­ï¼Œc->proc è¿˜æ˜¯æ—§å€¼ï¼
c->proc = p;
swtch(&c->context, &p->context);  // æ­¤æ—¶ä¸å˜é‡æˆç«‹
```

`RUNNABLE`çŠ¶æ€ä¹Ÿæ˜¯ä¸€ä¸ªä¸å˜é‡ï¼Œå¦‚æœè¿›ç¨‹æ˜¯`RUNNABLE`çŠ¶æ€ï¼Œç©ºé—²CPUçš„è°ƒåº¦å™¨å¿…é¡»èƒ½å¤Ÿå®‰å…¨åœ°è¿è¡Œå®ƒã€‚è¿™æ„å‘³ç€`p->context`å¿…é¡»ä¿å­˜è¿›ç¨‹çš„å¯„å­˜å™¨ï¼ˆå®ƒä»¬ä¸åœ¨çœŸå®å¯„å­˜å™¨ä¸­ï¼‰ï¼Œæ²¡æœ‰CPUåœ¨è¯¥è¿›ç¨‹çš„å†…æ ¸æ ˆä¸Šæ‰§è¡Œï¼Œä¸”æ²¡æœ‰CPUçš„`c->proc`æŒ‡å‘è¯¥è¿›ç¨‹ã€‚ä»£ç ä½“ç°åœ¨`yield()`ï¼š

```c
void yield(void)
{
  struct proc *p = myproc();
  acquire(&p->lock);
  p->state = RUNNABLE;    // è®¾ç½®çŠ¶æ€
  sched();                // è°ƒç”¨swtchä¿å­˜å¯„å­˜å™¨åˆ°p->context
  release(&p->lock);
}
```

è€Œè¿™äº›ä¸å˜é‡åœ¨æŒæœ‰`p->lock`æ—¶ç»å¸¸ä¸æˆç«‹ã€‚

```c
acquire(&p->lock);           // ğŸ”’ è·å–é”
if(p->state == RUNNABLE) {
  // âš ï¸ ä¸å˜é‡è¢«æš‚æ—¶ç ´åçš„æ—¶æœŸ
  p->state = RUNNING;        // çŠ¶æ€æ”¹å˜ï¼Œä½† c->proc è¿˜æœªæ›´æ–°
  c->proc = p;               // c->proc æ›´æ–°ï¼Œä½†å¯„å­˜å™¨è¿˜åœ¨ p->context ä¸­
  swtch(&c->context, &p->context);  // å¯„å­˜å™¨è¢«æ¢å¤ï¼Œä¸å˜é‡é‡æ–°æˆç«‹
  // ğŸ”“ é”çš„æ‰€æœ‰æƒè½¬ç§»ç»™è¿›ç¨‹
```

```c
// è¿›ç¨‹æŒæœ‰ p->lock
p->state = RUNNABLE;         // âš ï¸ çŠ¶æ€æ”¹å˜ï¼Œä½†å¯„å­˜å™¨è¿˜åœ¨CPUä¸­
swtch(&p->context, &mycpu()->context);  // å¯„å­˜å™¨è¢«ä¿å­˜ï¼Œä¸å˜é‡é‡æ–°æˆç«‹
// ğŸ”“ é”çš„æ‰€æœ‰æƒè½¬ç§»ç»™è°ƒåº¦å™¨
```

ç»´æŠ¤è¿™ç§ä¸å˜æ€§ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ`xv6`ç»å¸¸åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­è·å–`p->lock`å¹¶åœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¸­é‡Šæ”¾å®ƒçš„åŸå› ã€‚

---

## Codeï¼šmycpu and myproc

`xv6`ç»å¸¸éœ€è¦ä¸€ä¸ªæŒ‡å‘å½“å‰è¿›ç¨‹çš„`proc`ç»“æ„çš„æŒ‡é’ˆã€‚å®ƒä¸ºæ¯ä¸ªCPUç»´æŠ¤ä¸€ä¸ª`struct cpu`ï¼Œè¿™ä¸ªç»“æ„è®°å½•äº†å½“å‰åœ¨è¯¥CPUä¸Šè¿è¡Œçš„è¿›ç¨‹ã€CPUè°ƒåº¦å™¨çº¿ç¨‹çš„ä¿å­˜å¯„å­˜å™¨ä»¥åŠç®¡ç†ä¸­æ–­ç¦ç”¨æ‰€éœ€çš„åµŒå¥—è‡ªæ—‹é”è®¡æ•°ã€‚

```c
// Per-CPU state.
struct cpu {
Â  struct proc *proc; Â  Â  Â  Â  Â // The process running on this cpu, or null.
Â  struct context context; Â  Â  // swtch() here to enter scheduler().
Â  int noff; Â  Â  Â  Â  Â  Â  Â  Â  Â  // Depth of push_off() nesting.
Â  int intena; Â  Â  Â  Â  Â  Â  Â  Â  // Were interrupts enabled before push_off()?
};
```

`mycpu()`è¿”å›æŒ‡å‘å½“å‰CPUçš„`struct cpu`çš„æŒ‡é’ˆï¼ŒRISC-Vä¼šä¸ºæ¯ä¸ªCPUç¼–å·ï¼Œç»™æ¯ä¸ªCPUä¸€ä¸ª`hartid`ï¼Œ`xv6`åˆ™ä¼šç¡®ä¿åœ¨å†…æ ¸ä¸­è¿è¡Œæ—¶ï¼Œæ¯ä¸ªCPUçš„`hartid`éƒ½å­˜å‚¨åœ¨è¯¥CPUçš„`tp`å¯„å­˜å™¨ä¸­ã€‚è¿™ä½¿å¾—`mycpu()`å¯ä»¥ä½¿ç”¨`tp`æ¥ç´¢å¼•ä¸€ä¸ª`cpu`ç»“æ„æ•°ç»„ã€‚å®é™…ä¸Šè¿™æ ·çš„æœºåˆ¶æ ¹æœ¬åœ¨äºRISC-Væ¶æ„ï¼Œç›‘ç£æ¨¡å¼æ— æ³•ç›´æ¥è¯»å–`hartid`ï¼Œåªèƒ½ç”¨`tp`å¯„å­˜å™¨å½“â€œä¸­è½¬ç«™â€ã€‚

åœ¨CPUå¯åŠ¨åºåˆ—çš„æ—©æœŸï¼Œä»åœ¨æœºå™¨æ¨¡å¼ä¸‹ï¼Œ`mstart`å‡½æ•°ä¼šè®¾ç½®`tp`ï¼š

```c
// keep each CPU's hartid in its tp register, for cpuid().
int id = r_mhartid();  // åœ¨æœºå™¨æ¨¡å¼ä¸‹è¯»å–çœŸå®hartid
w_tp(id);              // ä¿å­˜åˆ°tpå¯„å­˜å™¨
```

ç„¶åè¿”å›ç”¨æˆ·ç©ºé—´å‰ï¼Œåœ¨`trampoline`é¡µä¸­ä¿å­˜å†…æ ¸çš„`tp`å€¼ï¼š

```c
// usertrapret() å‡½æ•°ä¸­
p->trapframe->kernel_hartid = r_tp();  // ä¿å­˜å½“å‰tpåˆ°trapframe
```

è¿™æ˜¯å› ä¸ºç”¨æˆ·è¿›ç¨‹å¯èƒ½ä¼šä¿®æ”¹`tp`å¯„å­˜å™¨ã€‚

æœ€åï¼Œ`uservec`ä»ç”¨æˆ·ç©ºé—´è¿”å›å†…æ ¸æ—¶æ¢å¤ä¿å­˜çš„`tp`å¯„å­˜å™¨ï¼š

```assembly
# uservec ä¸­çš„å…³é”®ä»£ç 
# make tp hold the current hartid, from p->trapframe->kernel_hartid
ld tp, 32(a0)  # ä»trapframeæ¢å¤tpå¯„å­˜å™¨
```

ä¸€ä¸ªå®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸå¦‚ä¸‹ï¼š

```text
å¯åŠ¨é˜¶æ®µ (æœºå™¨æ¨¡å¼):
mstart() â†’ r_mhartid() â†’ w_tp(hartid) â†’ åˆ‡æ¢åˆ°ç›‘ç£æ¨¡å¼

å†…æ ¸è¿è¡Œé˜¶æ®µ (ç›‘ç£æ¨¡å¼):
cpuid() â†’ r_tp() â†’ è¿”å›å½“å‰CPU ID

ç”¨æˆ·ç©ºé—´åˆ‡æ¢ (ç›‘ç£æ¨¡å¼):
usertrapret() â†’ ä¿å­˜tpåˆ°trapframe â†’ userret() â†’ ç”¨æˆ·ç¨‹åºè¿è¡Œ
                                      â†“
ç”¨æˆ·ç¨‹åº (å¯èƒ½ä¿®æ”¹tp) â†’ ç³»ç»Ÿè°ƒç”¨/ä¸­æ–­ â†’ uservec() â†’ æ¢å¤tp
```

ä½†`cpuid`å’Œ`mycpu`çš„è¿”å›å€¼ä»ç„¶æœ‰å¯èƒ½å‡ºé”™ï¼Œæ¯”å¦‚å®šæ—¶å™¨ä¸­æ–­å¹¶å¯¼è‡´çº¿ç¨‹è®©å‡ºCPUï¼Œç„¶åç§»åŠ¨åˆ°å¦ä¸€ä¸ªCPUï¼Œé‚£ä¹ˆå…ˆå‰è¿”å›çš„å€¼å°†ä¸å†æ­£ç¡®ã€‚

```c
// é”™è¯¯ä»£ç ç¤ºä¾‹
int my_cpu_id = cpuid();           // å‡è®¾è¿”å›CPU 0
struct cpu *c = &cpus[my_cpu_id];  // è·å–CPU 0çš„ç»“æ„ä½“
// âš ï¸ è¿™é‡Œå‘ç”Ÿæ—¶é’Ÿä¸­æ–­ï¼è¿›ç¨‹è¢«è°ƒåº¦åˆ°CPU 1
c->some_field = value;             // ğŸ’¥ é”™è¯¯ï¼ä¿®æ”¹äº†CPU 0çš„æ•°æ®ï¼Œä½†å®é™…è¿è¡Œåœ¨CPU 1ä¸Š
```

ä¸ºé¿å…è¿™ä¸ªé—®é¢˜ï¼Œ`xv6`è¦æ±‚è°ƒç”¨è€…ç¦ç”¨ä¸­æ–­ï¼Œå¹¶ä¸”åªæœ‰åœ¨ä½¿ç”¨å®Œè¿”å›çš„`struct cpu`åæ‰é‡æ–°å¯ç”¨ä¸­æ–­ã€‚

```c
struct proc*
myproc(void)
{
  push_off();                    // â­ å…³é—­ä¸­æ–­
  struct cpu *c = mycpu();       // å®‰å…¨åœ°è·å–å½“å‰CPU
  struct proc *p = c->proc;      // è·å–å½“å‰è¿›ç¨‹
  pop_off();                     // â­ æ¢å¤ä¸­æ–­
  return p;
}
```

---

## Sleep and wakeup

å‰é¢çš„è°ƒåº¦å’Œé”éƒ½æ˜¯åœ¨ç»™å¦ä¸€ä¸ªè¿›ç¨‹éšè—æœ¬è¿›ç¨‹çš„å­˜åœ¨ï¼Œè¿™ä¸ªæœºåˆ¶åˆ™æ˜¯ä¸€ä¸ªå¸®åŠ©è¿›ç¨‹è¿›è¡Œæœ‰æ„äº¤äº’çš„æŠ½è±¡ã€‚å®ƒå…è®¸ä¸€ä¸ªè¿›ç¨‹åœ¨ç­‰å¾…äº‹ä»¶æ—¶ç¡çœ ï¼Œè€Œå¦ä¸€ä¸ªè¿›ç¨‹åœ¨äº‹ä»¶å‘ç”Ÿåå”¤é†’å®ƒã€‚*Sleep and wakeup*é€šå¸¸è¢«ç§°ä½œ**sequence coordination**æˆ–è€…**conditional synchronization mechanisms**ã€‚

é¦–å…ˆè€ƒè™‘ä¸€ç§ç§°ä¸º*semaphore*çš„åŒæ­¥æœºåˆ¶ï¼Œå®ƒåè°ƒç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ã€‚ä¿¡å·é‡ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å¹¶æä¾›ä¸¤ä¸ªæ“ä½œï¼šVæ“ä½œé’ˆå¯¹ç”Ÿäº§è€…ï¼Œå¢åŠ è®¡æ•°ï¼›Pæ“ä½œé’ˆå¯¹æ¶ˆè´¹è€…ï¼Œç­‰å¾…ç›´åˆ°è®¡æ•°éé›¶ï¼Œç„¶åé€’å‡è®¡æ•°å¹¶è¿”å›ã€‚å¦‚æœåªæœ‰ä¸€ä¸ªç”Ÿäº§è€…çº¿ç¨‹å’Œä¸€ä¸ªæ¶ˆè´¹è€…çº¿ç¨‹ï¼Œå¹¶ä¸”æ‰§è¡Œåœ¨ä¸åŒçš„CPUä¸Šï¼Œåˆ™å¯é‡‡ç”¨ä¸‹é¢çš„å®ç°ï¼š

```python
struct semaphore {
  struct spinlock lock;
  int count;
}

void
V(struct semaphore *s)
{
   acquire(&s->lock);
   s->count += 1;
   release(&s->lock);
}

void
P(struct semaphore *s)
{
   while(s->count == 0);
   acquire(&s->lock);
   s->count -= 1;
   release(&s->lock);
}
```

ä½†ä¸Šé¢å®ç°çš„å¼€é”€å¾ˆå¤§ã€‚ å¦‚æœç”Ÿäº§è€…å¾ˆå°‘è¡ŒåŠ¨ï¼Œæ¶ˆè´¹è€…å°†èŠ±è´¹å¤§éƒ¨åˆ†æ—¶é—´åœ¨`while`å¾ªç¯ä¸­è‡ªæ—‹ã€‚é¿å…è¿™ä¸ªéœ€è¦ä¸€ç§æ–¹æ³•è®©æ¶ˆè´¹è€…è®©å‡ºCPUï¼Œå¹¶åœ¨`V`å¢åŠ `count`åæ¢å¤æ‰§è¡Œã€‚è€ƒè™‘`sleep`ä¸`wakeup`è°ƒç”¨ã€‚`sleep(chan)`ä½¿è¿›ç¨‹ç¡çœ å¹¶é‡Šæ”¾CPUï¼Œç„¶åè¯¥è¿›ç¨‹è¢«åŠ å…¥`chan`å¯¹åº”çš„ç­‰å¾…é€šé“ä¸­ã€‚`wakeup(chan)`å”¤é†’æ‰€æœ‰åœ¨`chan`ä¸Šç¡çœ çš„è¿›ç¨‹ï¼Œä½¿å®ƒä»¬çš„`sleep`è°ƒç”¨è¿”å›ï¼Œå¦‚æœ`chan`ä¸­æ²¡æœ‰è¿›ç¨‹ç­‰å¾…ï¼Œåˆ™ä¸åšä»»ä½•æ“ä½œã€‚ç°åœ¨å¯ä»¥ä¿®æ”¹ä¿¡å·é‡çš„å®ç°ï¼š

```c
void
V(struct semaphore *s)
{
   acquire(&s->lock);
   s->count += 1;
   wakeup(s);
   release(&s->lock);
}

void
P(struct semaphore *s)
{
   while(s->count == 0)
     sleep(s);
   acquire(&s->lock);
   s->count -= 1;
   release(&s->lock);
}
```

ä½†ç°åœ¨è¿™ç§è®¾è®¡ä¾ç„¶æœ‰é—®é¢˜ï¼Œå‡è®¾`P`å‘ç°`s->count == 0`ä½†è¿˜æ²¡æœ‰è¿›å…¥ä¸‹ä¸€è¡Œï¼Œè€Œ`V`è¿è¡Œåœ¨å¦ä¸€ä¸ªCPUï¼Œå®ƒå°†`s->count`æ”¹ä¸ºéé›¶å¹¶è°ƒç”¨`wakeup`ï¼Œè€Œ`wakeup`ä¼šå‘ç°æ²¡æœ‰è¿›ç¨‹åœ¨ç¡çœ ï¼Œå› æ­¤ä»€ä¹ˆä¹Ÿä¸åšï¼Œè¿™æ—¶`P`è°ƒç”¨`sleep`è¿›å…¥ç¡çœ ï¼Œè¿™æ ·çš„è¯`P`æ­£åœ¨ç­‰å¾…ä¸€ä¸ªå·²ç»å‘ç”Ÿçš„`V`è°ƒç”¨ï¼Œå¹¶å¯èƒ½æ°¸è¿œç­‰å¾…ã€‚

è¯¥é—®é¢˜çš„æ ¹æºåœ¨äºï¼Œ**`P`åªåœ¨`s->count == 0`æ—¶ç¡çœ **è¿™ä¸€ä¸å˜é‡è¢«`V`åœ¨é”™è¯¯æ—¶åˆ»çš„è¿è¡Œç ´åäº†ã€‚ä¿æŠ¤è¿™ä¸ªä¸å˜é‡çš„æ–¹æ³•æ˜¯å°†`P`ä¸­é”çš„è·å–ç§»åŠ¨ä½ç½®ã€‚

```c
void
V(struct semaphore *s)
{
   acquire(&s->lock);
   s->count += 1;
   wakeup(s);
   release(&s->lock);
}

void
P(struct semaphore *s)
{
   acquire(&s->lock);
   while(s->count == 0)
     sleep(s);
   s->count -= 1;
   release(&s->lock);
}
```

ç°åœ¨è¿™ä¸ªç‰ˆæœ¬åˆå¯èƒ½å¯¼è‡´æ­»é”ï¼Œ`P`åœ¨ç¡çœ æ—¶æŒæœ‰é”ã€‚`V`å°†æ°¸è¿œé˜»å¡ç­‰å¾…é”ã€‚é€šè¿‡ä¿®æ”¹`sleep`çš„æ¥å£å¯ä»¥ä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚è°ƒç”¨è€…å¿…é¡»å°†é”ä¼ é€’ç»™`sleep`ï¼Œè¿™æ ·åœ¨è°ƒç”¨è¿›ç¨‹è¢«æ ‡è®°ä¸ºç¡çœ å¹¶åœ¨ç¡çœ é€šé“ä¸Šç­‰å¾…åï¼Œ`sleep`å°±å¯ä»¥é‡Šæ”¾é”ã€‚è¿™æŠŠé”ä¼šå¼ºåˆ¶ä¸€ä¸ªå¹¶å‘çš„`P`è¿›ç¨‹è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œä»¥ä¾¿`wakeup`èƒ½ç­‰å¾…`P`å°†è‡ªèº«è®¾ç½®ä¸ºç¡çœ ï¼Œç„¶å`wakeup`ä¼šæ‰¾åˆ°å¤„äºç¡çœ çŠ¶æ€çš„æ¶ˆè´¹è€…å°†å…¶å”¤é†’ã€‚ä¸€æ—¦æ¶ˆè´¹è€…å†æ¬¡é†’æ¥ï¼Œ`sleep`ä¼šåœ¨è¿”å›ä¹‹å‰é‡æ–°è·å–è¯¥é”ã€‚

```c
void
V(struct semaphore *s)
{
   acquire(&s->lock);
   s->count += 1;
   wakeup(s);
   release(&s->lock);
}

void
P(struct semaphore *s)
{
   acquire(&s->lock);
   while(s->count == 0)
     sleep(s, &s->lock);
   s->count -= 1;
   release(&s->lock);
}
```

---

## Codeï¼šSleep and wakeup

ç°åœ¨æ¥çœ‹`sleep`å’Œ`wakeup`çš„å®ç°ã€‚

```c
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
  struct proc *p = myproc();
  
  // Must acquire p->lock in order to
  // change p->state and then call sched.
  // Once we hold p->lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup locks p->lock),
  // so it's okay to release lk.

  acquire(&p->lock);  //DOC: sleeplock1
  release(lk);

  // Go to sleep.
  p->chan = chan;
  p->state = SLEEPING;

  sched();

  // Tidy up.
  p->chan = 0;

  // Reacquire original lock.
  release(&p->lock);
  acquire(lk);
}

// Wake up all processes sleeping on chan.
// Must be called without any p->lock.
void
wakeup(void *chan)
{
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    if(p != myproc()){
      acquire(&p->lock);
      if(p->state == SLEEPING && p->chan == chan) {
        p->state = RUNNABLE;
      }
      release(&p->lock);
    }
  }
}
```

`sleep`æŠŠå½“å‰è¿›ç¨‹æ ‡è®°ä¸º`SLEEPING`ï¼Œç„¶åè°ƒç”¨`sched`é‡Šæ”¾CPUï¼Œ`wakeup`æŸ¥æ‰¾ç»™å®šç­‰å¾…é€šé“ä¸Šç¡çœ çš„è¿›ç¨‹å¹¶å°†å…¶æ ‡è®°ä¸º`RUNNABLE`ï¼Œ`sleep`å’Œ`wakeup`çš„è°ƒç”¨è€…å¯ä»¥ä½¿ç”¨ä»»ä½•æ–¹ä¾¿çš„æ•°å­—ä½œä¸ºé€šé“ï¼Œ`xv6`é€šå¸¸ä½¿ç”¨å‚ä¸ç­‰å¾…çš„å†…æ ¸æ•°æ®ç»“æ„çš„å†…å­˜åœ°å€ã€‚

`sleep`è·å–`p->lock`åï¼Œè¿™ä¸ªå³å°†è¿›å…¥ç¡çœ çš„è¿›ç¨‹åŒæ—¶æŒæœ‰`p->lock`å’Œ`lk`ï¼Œ`P`è¿›ç¨‹æŒæœ‰`lk`å¯ä»¥ç¡®ä¿`V`è¿›ç¨‹æ— æ³•è°ƒç”¨`wakeup(chan)`ã€‚åœ¨`P`æŒæœ‰`p->lock`åå°±å¯ä»¥é‡Šæ”¾`lk`äº†ï¼Œå…¶ä»–è¿›ç¨‹å¯èƒ½ä¼šè°ƒç”¨`wakeup(chan)`ï¼Œä½†`wakeup`ä¼šç­‰å¾…è·å–`p->lock`ï¼Œè¿™æ ·å®ƒä¼šç­‰å¾…`sleep`å®Œæˆè¿›ç¨‹ç¡çœ ï¼Œä»è€Œé¿å…`wakeup`é”™è¿‡`sleep`ã€‚

ä½†å¦‚æœ`lk`å’Œ`p->lock`æ˜¯ä¸€ä¸ªé”ï¼Œé‚£ä¹ˆ`sleep(p, &p->lock)`åœ¨è·å–`p->lock`æ—¶ä¼šä¸è‡ªèº«å‘ç”Ÿæ­»é”ã€‚å¦‚æœè°ƒç”¨`sleep`çš„è¿›ç¨‹å·²ç»æŒæœ‰`p->lock`ï¼Œå®ƒä¹Ÿä¸éœ€è¦åšé¢å¤–çš„äº‹æ¥é¿å…é”™è¿‡å¹¶å‘çš„`wakeup`ï¼Œå®ƒå¯ä»¥è®°å½•ç¡çœ é€šé“ï¼Œå°†è¿›ç¨‹çŠ¶æ€æ”¹ä¸º`SLEEPING`å¹¶è°ƒç”¨`sched`æ¥ä½¿è¿›ç¨‹è¿›å…¥ç¡çœ çŠ¶æ€ã€‚

å³ä½¿æœ‰å¤šä¸ªè¿›ç¨‹åœ¨åŒä¸€é€šé“ä¸Šä¼‘çœ ï¼Œä¹Ÿæ²¡æœ‰é—®é¢˜ï¼Œå…¶ä»–è¿›ç¨‹å°½ç®¡ä¼šè¢«å”¤é†’ï¼Œä½†å®ƒä»¬ä¼šå‘ç°æ²¡æœ‰æ•°æ®å¯è¯»ï¼Œè¿™æ¬¡å”¤é†’æ˜¯â€œè™šå‡çš„â€ï¼Œå®ƒä»¬ä¹Ÿä¼šå†æ¬¡ä¼‘çœ ã€‚è€Œå¦‚æœä¸¤ä¸ªä½¿ç”¨`sleep`å’Œ`wakeup`çš„æ“ä½œæ„å¤–é€‰æ‹©äº†ç›¸åŒçš„é€šé“ï¼Œä¹Ÿæ²¡æœ‰é—®é¢˜ï¼Œä¸ä¸Šé¢ä¸€æ ·å®ƒä»¬ä¼šçœ‹åˆ°â€œè™šå‡â€çš„å”¤é†’ã€‚

`sleep/wakeup`çš„é­…åŠ›åœ¨äºå®ƒå³è½»é‡çº§ï¼ˆæ— éœ€åˆ›å»ºç‰¹æ®Šçš„æ•°æ®ç»“æ„ä½œä¸ºç¡çœ é€šé“ï¼‰ï¼Œåˆæä¾›äº†ä¸€å±‚é—´æ¥æ€§ï¼ˆè°ƒç”¨è€…æ— éœ€çŸ¥é“å®ƒä»¬æ­£åœ¨ä¸å“ªä¸ªç‰¹å®šè¿›ç¨‹äº¤äº’ï¼‰ã€‚

---

## Codeï¼šPipes

`pipe`ä¹Ÿä½¿ç”¨`sleep`å’Œ`wakeup`æ¥åŒæ­¥ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ã€‚æ¯ä¸ªç®¡é“ç”±ä¸€ä¸ª`struct pipe`è¡¨ç¤ºï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªé”å’Œä¸€ä¸ªæ•°æ®ç¼“å†²åŒºã€‚å­—æ®µ`nread`å’Œ`nwrite`åˆ†åˆ«ç»Ÿè®¡ä»ç¼“å†²åŒºè¯»å–å’Œå†™å…¥çš„æ€»å­—èŠ‚æ•°ã€‚ç¼“å†²åŒºæ˜¯å¾ªç¯çš„ï¼šåœ¨`buf[PIPESIZE - 1]`åå†™å…¥çš„ä¸‹ä¸€ä¸ªå­—èŠ‚æ˜¯`buf[0]`ã€‚è®¡æ•°ä¸ä¼šå¾ªç¯ã€‚è¿™æ ·å¯ä»¥åŒºåˆ†æ»¡ç¼“å†²åŒº`nwrite == nread + PIPESIZE`å’Œç©ºç¼“å†²åŒº`nwrite == nread`ï¼Œä½†ä¹Ÿæ„å‘³ç€ç´¢å¼•ç¼“å†²åŒºæ—¶å¿…é¡»ç”¨`buf[nread % PIPESIZE]`ã€‚

```c
struct pipe {
  struct spinlock lock;
  char data[PIPESIZE];
  uint nread;     // number of bytes read
  uint nwrite;    // number of bytes written
  int readopen;   // read fd is still open
  int writeopen;  // write fd is still open
};
```

å‡è®¾åœ¨ä¸¤ä¸ªä¸åŒçš„CPUä¸ŠåŒæ—¶è°ƒç”¨`piperead`å’Œ`pipewrite`ï¼Œ`pipewrite`å…ˆè·å–ç®¡é“çš„é”ï¼Œè¯¥é”ä¿æŠ¤è®¡æ•°ã€æ•°æ®ä»¥åŠå…¶ä»–ç›¸å…³çš„ä¸å˜é‡ã€‚`piperead`éšåä¹Ÿå°è¯•è·å–é”ä½†å¤±è´¥ï¼Œå®ƒä¼šåœ¨`acquire`ä¸­è‡ªæ—‹ç­‰å¾…ã€‚åŒæ—¶ï¼Œ`pipewrite`å¾ªç¯éå†è¦å†™å…¥çš„å­—èŠ‚å¹¶ä¸€æ¬¡å°†å®ƒä»¬æ·»åŠ åˆ°ç®¡é“ä¸­ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å¯èƒ½å‘ç”Ÿç¼“å†²åŒºå¡«æ»¡çš„æƒ…å†µã€‚è¿™æ—¶`pipewrite`ä¼šè°ƒç”¨`wakeup`æ¥æé†’ä»»ä½•ç¡çœ çš„ç®¡é“è¯»è€…ç¼“å†²åŒºä¸­æœ‰æ•°æ®ç­‰å¾…ï¼Œç„¶åå®ƒåœ¨`&pi->nwrite`ä¸Šç¡çœ ï¼Œç­‰å¾…è¯»è€…ä»ç¼“å†²åŒºä¸­å–å‡ºä¸€äº›å­—èŠ‚ã€‚`sleep`å°†`pipewrite`ç½®äºç¡çœ çŠ¶æ€æ—¶é‡Šæ”¾`pi->lock`ã€‚

```c
int
pipewrite(struct pipe *pi, uint64 addr, int n)
{
  int i = 0;
  struct proc *pr = myproc();

  acquire(&pi->lock);
  while(i < n){
    if(pi->readopen == 0 || killed(pr)){
      release(&pi->lock);
      return -1;
    }
    if(pi->nwrite == pi->nread + PIPESIZE){ //DOC: pipewrite-full
      wakeup(&pi->nread);
      sleep(&pi->nwrite, &pi->lock);
    } else {
      char ch;
      if(copyin(pr->pagetable, &ch, addr + i, 1) == -1)
        break;
      pi->data[pi->nwrite++ % PIPESIZE] = ch;
      i++;
    }
  }
  wakeup(&pi->nread);
  release(&pi->lock);

  return i;
}
```

è¿™æ—¶`pi->lock`å¯ç”¨ï¼Œ`piperead`ä¼šè·å–å®ƒå¹¶è¿›å…¥å…¶ä¸´ç•ŒåŒºï¼Œç„¶åæ‰§è¡Œè¯»å–å°†æ•°æ®ä»ç®¡é“ä¸­å¤åˆ¶å‡ºæ¥ã€‚è¿™æ—¶æœ‰å­—èŠ‚å¯ä¾›å†™å…¥ï¼Œ`piperead`ä¼šåœ¨è¿”å›ä¹‹å‰è°ƒç”¨`wakeup`æ¥å”¤é†’ä»»ä½•ç¡çœ çš„çš„å†™è€…ã€‚`wakeup`æ‰¾åˆ°åœ¨`&pi->nwrite`ä¸Šç¡çœ çš„è¿›ç¨‹å¹¶å°†è¯¥è¿›ç¨‹æ ‡è®°ä¸º`RUNNABLE`ã€‚

```c
int
piperead(struct pipe *pi, uint64 addr, int n)
{
  int i;
  struct proc *pr = myproc();
  char ch;

  acquire(&pi->lock);
  while(pi->nread == pi->nwrite && pi->writeopen){  //DOC: pipe-empty
    if(killed(pr)){
      release(&pi->lock);
      return -1;
    }
    sleep(&pi->nread, &pi->lock); //DOC: piperead-sleep
  }
  for(i = 0; i < n; i++){  //DOC: piperead-copy
    if(pi->nread == pi->nwrite)
      break;
    ch = pi->data[pi->nread++ % PIPESIZE];
    if(copyout(pr->pagetable, addr + i, &ch, 1) == -1)
      break;
  }
  wakeup(&pi->nwrite);  //DOC: piperead-wakeup
  release(&pi->lock);
  return i;
}
```

ç®¡é“ä»£ç ä¸ºè¯»å–è€…å’Œå†™å…¥è€…ä½¿ç”¨äº†ç‹¬ç«‹çš„ç¡çœ é€šé“`pi->nread`å’Œ`pi->nwrite`ï¼Œè¿™åœ¨ä¸€äº›æç«¯æƒ…å†µä¸‹ä¼šä½¿ç³»ç»Ÿæ›´åŠ é«˜æ•ˆï¼ŒåŒæ—¶â€œå¹¶å‘â€çŠ¶æ€ä¹Ÿä¼šä¸ä¸Šä¸€ç« ä¸€æ ·ï¼Œâ€œè™šå‡â€œå”¤é†’è€Œç»§ç»­ç¡çœ ã€‚

---

## Codeï¼šWaitã€exit and kill

ç¡çœ ä¸å”¤é†’å¯ä»¥ç”¨äºå¤šç§ç­‰å¾…åœºæ™¯ã€‚ä¸€ä¸ªä¾‹å­æ˜¯å­è¿›ç¨‹`exit`å’Œçˆ¶è¿›ç¨‹`wait`ä¹‹é—´çš„äº¤äº’ã€‚

åœ¨å­è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œçˆ¶è¿›ç¨‹å¯èƒ½å·²ç»å¤„äºä¸­ç¡çœ `wait`çŠ¶æ€ã€æˆ–è€…æ­£åœ¨æ‰§è¡Œå…¶ä»–æ“ä½œã€‚åœ¨åä¸€ç§æƒ…å†µä¸­ï¼Œåç»­çš„`wait`è°ƒç”¨å¿…é¡»èƒ½æ„ŸçŸ¥åˆ°å­è¿›ç¨‹çš„ç»ˆæ­¢ï¼Œå³ä¾¿å¯èƒ½æ˜¯åœ¨å­è¿›ç¨‹è°ƒç”¨`exit`å¾ˆä¹…ä¹‹åã€‚`xv6`è®°å½•å­è¿›ç¨‹ç»ˆæ­¢çŠ¶æ€ç›´åˆ°`wait`æ£€æµ‹åˆ°å®ƒçš„æ–¹å¼æ˜¯ï¼Œè®©`exit`å°†è°ƒç”¨è€…ç½®äº`ZOMBIE`çŠ¶æ€ï¼Œç›´åˆ°çˆ¶è¿›ç¨‹çš„`wait`å‡½æ•°å¯Ÿè§‰è¯¥çŠ¶æ€ï¼Œå°†å­è¿›ç¨‹çŠ¶æ€æ”¹ä¸º`UNUSED`ï¼Œå¤åˆ¶å­è¿›ç¨‹çš„é€€å‡ºçŠ¶æ€ï¼Œå¹¶å‘çˆ¶è¿›ç¨‹è¿”å›å­è¿›ç¨‹çš„è¿›ç¨‹IDã€‚è‹¥çˆ¶è¿›ç¨‹å…ˆäºå­è¿›ç¨‹é€€å‡ºï¼Œç³»ç»Ÿä¼šå°†å­è¿›ç¨‹è½¬äº¤ç»™`init`è¿›ç¨‹ï¼Œè€Œ`init`è¿›ç¨‹ä¼šæŒç»­è°ƒç”¨`wait`å‡½æ•°ï¼Œå› æ­¤æ¯ä¸ªå­è¿›ç¨‹æœ€ç»ˆéƒ½ä¼šæœ‰ä¸€ä¸ªçˆ¶è¿›ç¨‹æ¥å®Œæˆæ¸…ç†å·¥ä½œã€‚è¿™ç§æœºåˆ¶çš„ä¸»è¦å®ç°æŒ‘æˆ˜åœ¨äºï¼šçˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹çš„`wait`å’Œ`exit`æ“ä½œä¹‹é—´ï¼Œä»¥åŠ`exit`æ“ä½œäº’ç›¸ä¹‹é—´å¯èƒ½å‡ºç°çš„ç«äº‰æ¡ä»¶å’Œæ­»é”é—®é¢˜ã€‚

`wait`å‡½æ•°ä½¿ç”¨è°ƒç”¨è¿›ç¨‹çš„`p->lock`ä½œä¸ºæ¡ä»¶é”ï¼Œä»¥é¿å…å”¤é†’ä¸¢å¤±ï¼Œå¹¶ä¼šåœ¨å‡½æ•°å¼€å§‹æ—¶è·å–è¯¥é”ã€‚éšåï¼Œå®ƒæ‰«æè¿›ç¨‹è¡¨ï¼š
- å¦‚æœæ‰¾åˆ°ä¸€ä¸ªå¤„äº`ZOMBIE`çŠ¶æ€çš„å­è¿›ç¨‹ï¼Œå®ƒä¼šé‡Šæ”¾è¯¥å­è¿›ç¨‹çš„èµ„æºå’Œ`proc`ç»“æ„ä½“ï¼Œç„¶åå°†å­è¿›ç¨‹çš„é€€å‡ºçŠ¶æ€å¤åˆ¶åˆ°`wait`ä¼ å…¥çš„åœ°å€ï¼Œå¹¶è¿”å›å­è¿›ç¨‹çš„è¿›ç¨‹IDã€‚
- å¦‚æœ`wait`æ‰¾åˆ°ä¸€ä¸ªå­è¿›ç¨‹ä½†æ²¡æœ‰é€€å‡ºï¼Œå®ƒä¼šè°ƒç”¨`sleep`ç­‰å¾…å…¶ä¸­æŸä¸ªå­è¿›ç¨‹é€€å‡ºï¼Œç„¶åé‡æ–°æ‰«æã€‚è¿™é‡Œ`sleep`é‡Šæ”¾çš„æ¡ä»¶é”æ˜¯ç­‰å¾…è¿›ç¨‹çš„`p->lock`ã€‚`wait`é€šå¸¸æŒæœ‰ä¸¤ä¸ªé”ï¼Œå®ƒä¼šå…ˆè·å–è‡ªå·±çš„é”ï¼Œç„¶åå°è¯•è·å–å­è¿›ç¨‹çš„é”ã€‚å› æ­¤`xv6`çš„æ‰€æœ‰ç›¸å…³æ“ä½œå¿…é¡»éµå¾ªç›¸åŒçš„åŠ é”é¡ºåºï¼ˆå…ˆçˆ¶è¿›ç¨‹ï¼Œåå­è¿›ç¨‹ï¼‰ä»¥é¿å…æ­»é”ã€‚

```c
// Wait for a child process to exit and return its pid.
// Return -1 if this process has no children.
int
wait(uint64 addr)
{
  struct proc *pp;
  int havekids, pid;
  struct proc *p = myproc();

  acquire(&wait_lock);

  for(;;){
    // Scan through table looking for exited children.
    havekids = 0;
    for(pp = proc; pp < &proc[NPROC]; pp++){
      if(pp->parent == p){
        // make sure the child isn't still in exit() or swtch().
        acquire(&pp->lock);

        havekids = 1;
        if(pp->state == ZOMBIE){
          // Found one.
          pid = pp->pid;
          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
                                  sizeof(pp->xstate)) < 0) {
            release(&pp->lock);
            release(&wait_lock);
            return -1;
          }
          freeproc(pp);
          release(&pp->lock);
          release(&wait_lock);
          return pid;
        }
        release(&pp->lock);
      }
    }

    // No point waiting if we don't have any children.
    if(!havekids || killed(p)){
      release(&wait_lock);
      return -1;
    }
    
    // Wait for a child to exit.
    sleep(p, &wait_lock);  //DOC: wait-sleep
  }
}
```

`wait`é€šè¿‡éå†æ¯ä¸ªè¿›ç¨‹çš„`np->parent`å­—æ®µæ¥æŸ¥æ‰¾å­è¿›ç¨‹ã€‚å®ƒè®¿é—®`np->parent`æ—¶æ— éœ€æŒæœ‰`np->lock`ï¼Œè¿™çœ‹ä¼¼è¿åäº†â€œå…±äº«å˜é‡å¿…é¡»ç”±é”ä¿æŠ¤â€çš„è§„åˆ™ï¼Œä½†æ˜¯åœ¨æ­¤åœºæ™¯ä¸‹æ˜¯å®‰å…¨çš„ï¼ŒåŸå› åœ¨äºï¼š
- è¿›ç¨‹çš„`parent`å­—æ®µä»…ç”±å…¶çˆ¶è¿›ç¨‹ä¿®æ”¹ã€‚
- è‹¥`np->parent == p`æˆç«‹ï¼Œé™¤éå½“å‰è¿›ç¨‹ä¸»åŠ¨ä¿®æ”¹ï¼Œå¦åˆ™å®ƒçš„å€¼ä¸ä¼šæ”¹å˜ã€‚
- è‹¥`np`æ˜¯å½“å‰è¿›ç¨‹çš„ç¥–å…ˆï¼Œè·å–`np->lock`å¯èƒ½å› ä¸ºè¿åâ€œå…ˆçˆ¶åå­â€çš„åŠ é”é¡ºåºè€Œå¯¼è‡´æ­»é”ï¼Œå› æ­¤ä¸æŒæœ‰é”è®¿é—®`parent`å­—æ®µä¹Ÿæ˜¯å¿…è¦çš„è®¾è®¡å¦¥åã€‚

`exit`å‡½æ•°è´Ÿè´£è®°å½•é€€å‡ºçŠ¶æ€ã€é‡Šæ”¾éƒ¨åˆ†èµ„æºã€å°†å­è¿›ç¨‹è¿‡ç»§ç»™`init`è¿›ç¨‹ã€å”¤é†’å¯èƒ½å¤„äº`wait`çŠ¶æ€çš„çˆ¶è¿›ç¨‹ã€å°†è‡ªèº«æ ‡è®°ä¸º`ZOMBIE`ã€å¹¶æ°¸ä¹…è®©å‡ºCPUã€‚

```c
// Exit the current process.  Does not return.
// An exited process remains in the zombie state
// until its parent calls wait().
void
exit(int status)
{
  struct proc *p = myproc();

  if(p == initproc)
    panic("init exiting");

  // Close all open files.
  for(int fd = 0; fd < NOFILE; fd++){
    if(p->ofile[fd]){
      struct file *f = p->ofile[fd];
      fileclose(f);
      p->ofile[fd] = 0;
    }
  }

  begin_op();
  iput(p->cwd);
  end_op();
  p->cwd = 0;

  acquire(&wait_lock);

  // Give any children to init.
  reparent(p);

  // Parent might be sleeping in wait().
  wakeup(p->parent);
  
  acquire(&p->lock);

  p->xstate = status;
  p->state = ZOMBIE;

  release(&wait_lock);

  // Jump into the scheduler, never to return.
  sched();
  panic("zombie exit");
}
```

åœ¨å°†è‡ªèº«çŠ¶æ€è®¾ç½®ä¸º`ZOMBIE`å¹¶å”¤é†’çˆ¶è¿›ç¨‹æ—¶ï¼Œå¿…é¡»æŒæœ‰çˆ¶è¿›ç¨‹çš„é”ï¼Œå› ä¸ºè¿™æŠŠé”æ˜¯é˜²æ­¢å”¤é†’ä¸¢å¤±çš„æ¡ä»¶é”ï¼Œè‹¥ä¸æŒæœ‰è¯¥é”ï¼Œçˆ¶è¿›ç¨‹å¯èƒ½æ— æ³•æ­£ç¡®æ„ŸçŸ¥å­è¿›ç¨‹çš„é€€å‡ºçŠ¶æ€ã€‚å­è¿›ç¨‹è¿˜å¿…é¡»æŒæœ‰è‡ªå·±çš„`p->lock`ï¼Œå¦åˆ™çˆ¶è¿›ç¨‹å¯èƒ½ä¼šçœ‹åˆ°å®ƒå¤„äº`ZOMBIE`çŠ¶æ€å¹¶åœ¨å®ƒä»åœ¨è¿è¡Œæ—¶é‡Šæ”¾å®ƒã€‚é”çš„è·å–é¡ºåºä¹Ÿå¾ˆé‡è¦ï¼Œå¿…é¡»å…ˆè·å–çˆ¶è¿›ç¨‹çš„é”å†è·å–å­è¿›ç¨‹çš„é”ã€‚

`exit`è°ƒç”¨çš„å”¤é†’å‡½æ•°åªå”¤é†’çˆ¶è¿›ç¨‹ï¼Œä¸”åªæœ‰çˆ¶è¿›ç¨‹åœ¨`wait`ä¸­ç¡çœ æ—¶æ‰å”¤é†’ã€‚åœ¨è®¾ç½®`ZOMBIE`çŠ¶æ€å‰å”¤é†’çˆ¶è¿›ç¨‹æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºçˆ¶è¿›ç¨‹ä¼šåœ¨`wait`å¾ªç¯ä¸­ç­‰å¾…å­è¿›ç¨‹é‡Šæ”¾`p->lock`å¹¶å®ŒæˆçŠ¶æ€æ›´æ–°åï¼Œæ‰èƒ½æ­£ç¡®æ‰«æåˆ°å­è¿›ç¨‹ã€‚

`kill`å‡½æ•°ç”¨äºè¯·æ±‚ç»ˆæ­¢å…¶ä»–è¿›ç¨‹ï¼Œä½†ä¸ä¼šç›´æ¥é”€æ¯ç›®æ ‡è¿›ç¨‹ã€‚å› ä¸ºç›®æ ‡è¿›ç¨‹å¯èƒ½æ­£åœ¨å…¶ä»–CPUä¸Šæ‰§è¡Œï¼Œä¸”å¯èƒ½å¤„äºæ›´æ–°å†…æ ¸æ•°æ®ç»“æ„çš„æ•æ„Ÿé˜¶æ®µã€‚`kill`çš„æ ¸å¿ƒæ“ä½œä»…ä»…æ˜¯è®¾ç½®`p->killed`ï¼Œå¹¶ä¸”å”¤é†’ç›®æ ‡è¿›ç¨‹ï¼ˆå¦‚æœå®ƒå¤„åœ¨ç¡çœ çŠ¶æ€ï¼‰ã€‚
- å¦‚æœç›®æ ‡è¿›ç¨‹åœ¨ç”¨æˆ·ç©ºé—´è¿è¡Œï¼Œä¼šé€šè¿‡ç³»ç»Ÿè°ƒç”¨æˆ–å®šæ—¶å™¨ä¸­æ–­è¿›å…¥å†…æ ¸ï¼Œæ­¤æ—¶`usertrap`ä¼šæ£€æŸ¥`p->killed`æ ‡å‡†å¹¶è°ƒç”¨`exit`ã€‚
- å¦‚æœç›®æ ‡è¿›ç¨‹å¤„äºç¡çœ ä¸­ï¼Œ`kill`ä¼šè°ƒç”¨`wakeup`ä½¿ç›®æ ‡è¿›ç¨‹ä»`sleep`ä¸­è¿”å›ï¼Œ`xv6`çš„`sleep`è°ƒç”¨é€šå¸¸åŒ…å«åœ¨`while`å¾ªç¯ä¸­ï¼Œè¿”å›åä¼šé‡æ–°æ£€æŸ¥æ¡ä»¶å’Œ`p->killed`æ ‡å¿—ã€‚è‹¥å·²è®¾ç½®ï¼Œåˆ™è¿›ç¨‹ä¼šæ”¾å¼ƒå½“å‰æ“ä½œï¼Œè¿”å›åˆ°`trap`ï¼Œå†æ¬¡æ£€æŸ¥æ ‡å¿—å¹¶é€€å‡ºã€‚
- è¿˜æœ‰ä¸€äº›ç‰¹æ®Šçš„`sleep`å¾ªç¯æ²¡æœ‰æ£€æŸ¥`p->killed`ï¼ˆæ¯”å¦‚`virtio`ç£ç›˜é©±åŠ¨ï¼‰ï¼Œå› ä¸ºç£ç›˜æ“ä½œéœ€ä¿è¯åŸå­æ€§ä»¥ç»´æŒæ–‡ä»¶ç³»ç»Ÿä¸€è‡´æ€§ã€‚æ­¤ç±»è¿›ç¨‹ä¼šåœ¨å®Œæˆå½“å‰ç³»ç»Ÿè°ƒç”¨åï¼Œæ‰åœ¨`usertrap`ä¸­å¤„ç†`killed`æ ‡å¿—å¹¶é€€å‡ºã€‚

---

## Real World

`xv6`è°ƒåº¦å™¨å®ç°äº†ä¸€ç§ç®€å•çš„è°ƒåº¦ç­–ç•¥ï¼Œå³ä¾æ¬¡è¿è¡Œæ¯ä¸ªè¿›ç¨‹ï¼Œè¿™ç§ç­–ç•¥ç§°ä¸º*round robin*ã€‚å®é™…çš„æ“ä½œç³»ç»Ÿæ›´åŠ å¤æ‚ï¼Œå…è®¸è¿›ç¨‹å…·æœ‰ä¼˜å…ˆçº§ï¼Œè¿˜éœ€è¦ä¿è¯å…¬å¹³æ€§å’Œé«˜ååé‡ç­‰ç­‰ã€‚

ç¡çœ å’Œå”¤é†’æ˜¯ä¸€ç§ç®€å•æœ‰æ•ˆçš„åŒæ­¥æ–¹æ³•ã€‚ä½†å®ƒé¢ä¸´çš„ç¬¬ä¸€ä¸ªæŒ‘æˆ˜å°±æ˜¯â€œä¸¢å¤±å”¤é†’â€é—®é¢˜ã€‚`Linux`å†…æ ¸çš„ç¡çœ ä½¿ç”¨äº†ä¸€ä¸ªæ˜¾å¼çš„è¿›ç¨‹é˜Ÿåˆ—ï¼Œç§°ä¸ºç­‰å¾…é˜Ÿåˆ—ï¼Œè€Œä¸ç®—ç­‰å¾…é€šé“ï¼Œé˜Ÿåˆ—æœ‰è‡ªå·±çš„å†…éƒ¨é”ã€‚

åœ¨`wakeup`ä¸­æ‰«ææ•´ä¸ªè¿›ç¨‹åˆ—è¡¨ä»¥æŸ¥æ‰¾å…·æœ‰åŒ¹é…`chan`çš„è¿›ç¨‹æ˜¯ä½æ•ˆçš„ï¼Œæ›´å¥½çš„æ–¹æ³•æ˜¯å°†`sleep`å’Œ`wakeup`ä¸­çš„`chan`æ›¿æ¢ä¸ºä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œè¯¥æ•°æ®ç»“æ„ä¿å­˜äº†åœ¨å®ƒä¸Šç¡çœ çš„è¿›ç¨‹åˆ—è¡¨ï¼Œä¾‹å¦‚`Linux`çš„ç­‰å¾…é˜Ÿåˆ—ã€‚